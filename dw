-- Decaying Winter: Made By Jonmaster1
--  Ctrl + Shift + L Toggle workbench esp
--  Ctrl + Shift + I Toggle Fog
--  Ctrl + U Enables the Item ESP to look for Tablets, Pills, Medkits, Speed stims, I4S Stims and IFAK
--  Ctrl + Y Enables the Item ESP to look for Blueprints, Snare tripwire and Proximity mines 
--  Shift + U Switches the NPC outline threshold from 40 to 100
--  Ctrl + [ removes NPC outlines
--  Ctrl + ] removes NPC headsize
--  Shift + [ Applies NPC outlines 
--  Shift + ] Applies NPC headsize
--  Ctrl + Shift + [ Toggles player outlines loop (ON by default)
--  Ctrl + Shift + ] Toggles SQ Headsize to lure out of castle and displays her health
--  Ctrl + Shift + M Opens the Headsize UI to change it
--  Ctrl + Shift + P Toggles TPwalkspeed (ON by default)
--  Ctrl + Shift + U Toggles Tpwalkspeed UI (default speed 0.34)
--  Ctrl + Shift + Y Toggles Barrel ESP (Increases Its Size For Trolling)
--  Ctrl + Shift + O Enables the Item ESP to look for Grenades to teamkill with
--  Shift + L places all ammo infront of you
--  Ctrl + L Places all ammo at Cursor
--  Ctrl + M Removes the gun Bilboards (Item ESP)
--  Shift + M Places bilboards on all the lose guns on the map (Item ESP)
--  Shift + Y Toggles Keybinds UI (Lists all these keybinds INGAME)
--  Ctrl + Shift + \ Places Bilboards on Inactive Cameras (for Waveultima)
--  Ctrl + \ Switches the headsize to 27 hit again to normalize
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local workspace = game:GetService("Workspace")

local HEAD_SIZE = 14 -- Enlarged head size for NPCs
local HEAD_TRANSPARENCY = 1 -- Transparency for enlarged heads
local NPC_CHAMS_COLOR = Color3.fromRGB(0, 145, 250) -- Preferred Blue chams for NPCs
local PLAYER_CHAMS_COLOR = Color3.fromRGB(0, 185, 35) -- Preferred Green chams for players

local playerChamsEnabled = true
local playerChamsLoop = nil
local npcChamsEnabled = false -- Tracks toggle state for NPC outlines
local guiOpen = false -- Tracks whether the UI is visible
local screenGui, frame, textBox, confirmButton
local npcChamsThreshold = 40 -- Default to 40
local headOverrideEnabled = false
local uiHeadSize = HEAD_SIZE


-- Check if the given model is an NPC
local function isNPC(model)
    if Players:GetPlayerFromCharacter(model) then
        return false -- Exclude players
    end

    -- Check if the model has a Humanoid to confirm it's an NPC
    return model:FindFirstChildOfClass("Humanoid") ~= nil
end

local function isPlayerRagdoll(model)
    local current = model
    while current do
        if current:IsA("Model") and current.Name:sub(1, 8) == "RAGDOLL_" then
            return true
        end
        current = current.Parent
    end
    return false
end

-- Exclude NPCs that are too far below the local player
local function isAboveThreshold(model, threshold)
    local localPlayer = Players.LocalPlayer
    local rootPart = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return false -- Fail-safe: Exclude all NPCs if the local player position is not available
    end

    local npcRootPart = model:FindFirstChild("HumanoidRootPart")
    if npcRootPart then
        return (npcRootPart.Position.Y >= rootPart.Position.Y - threshold)
    end

    return false -- Exclude if the NPC has no HumanoidRootPart
end

-- Change the head size, transparency, and collision of a character
local function changeHeadSize(head, enlarged)
    if head and head:IsA("BasePart") then
        if enlarged then
            head.Size = Vector3.new(HEAD_SIZE, HEAD_SIZE, HEAD_SIZE)
            head.Transparency = HEAD_TRANSPARENCY
            head.CanCollide = false -- Disable collisions
            head.Massless = true -- Prevent physics issues
        else
            head.Size = Vector3.new(1, 1, 1) -- Restore normal size
            head.Transparency = 0 -- Restore normal transparency
            head.CanCollide = true -- Restore collisions
            head.Massless = false -- Restore default physics
        end
    end
end

local exclusionCorner1 = Vector3.new(-146.27, -325.70, 186.72)
local exclusionCorner2 = Vector3.new(-11.03, -440.70, 639.68)

local function isInNPCExclusionZone(pos)
    local minX = math.min(exclusionCorner1.X, exclusionCorner2.X)
    local maxX = math.max(exclusionCorner1.X, exclusionCorner2.X)
    local minY = math.min(exclusionCorner1.Y, exclusionCorner2.Y)
    local maxY = math.max(exclusionCorner1.Y, exclusionCorner2.Y)
    local minZ = math.min(exclusionCorner1.Z, exclusionCorner2.Z)
    local maxZ = math.max(exclusionCorner1.Z, exclusionCorner2.Z)

    return pos.X >= minX and pos.X <= maxX and
           pos.Y >= minY and pos.Y <= maxY and
           pos.Z >= minZ and pos.Z <= maxZ
end

-- Function to toggle threshold between 40 and 80
local function toggleNPCChamsThreshold()
    if npcChamsThreshold == 40 then
        npcChamsThreshold = 100
    else
        npcChamsThreshold = 40
    end
    -- Reapply chams with the new threshold
    toggleNPCChams() -- This will reapply the chams with the new threshold value
end

-- Apply head size to ALL NPCs, no threshold check
local function applyNPCHeadSize()
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("Model") and isNPC(descendant) then
            local head = descendant:FindFirstChild("Head")
            if head and head:IsA("BasePart") and not isInNPCExclusionZone(head.Position) and not isPlayerRagdoll(descendant) then

                -- Check if all BASEPARTS inside the NPC model are above 40% transparency
                local allTransparentEnough = true
                for _, part in ipairs(descendant:GetChildren()) do
                    if part:IsA("BasePart") then
                        if part.Transparency < 0.4 then
                            allTransparentEnough = false
                            break
                        end
                    end
                end

                -- If all body parts are 40%-100% transparent, adjust head
                if allTransparentEnough then
                    head.Transparency = 0.85
                end

                changeHeadSize(head, true) -- Enlarge NPC head
            end
        end
    end
end

-- Revert head size on ALL NPCs, no threshold check
local function revertNPCHeadSize()
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("Model") and isNPC(descendant) then
            local head = descendant:FindFirstChild("Head")
            if head and head:IsA("BasePart") then
                changeHeadSize(head, false)
            end
        end
    end
end

-- Apply chams (outline only) to a character
local function applyChams(character, color)
    -- Remove existing chams to avoid duplication
    local existingChams = character:FindFirstChildOfClass("Highlight")
    if existingChams then
        existingChams:Destroy()
    end

    -- Create new chams (outline only)
    local chams = Instance.new("Highlight")
    chams.Adornee = character
    chams.Parent = character
    chams.FillTransparency = 1 -- Fully transparent fill
    chams.OutlineTransparency = 0.5 -- Fully visible outline
    chams.OutlineColor = color -- Set the outline color
end

local function startPlayerChamsLoop()
    if playerChamsLoop == nil then
        playerChamsLoop = task.spawn(function()
            while playerChamsEnabled do
                for _, player in pairs(Players:GetPlayers()) do
                    if player.Character then
                        applyChams(player.Character, PLAYER_CHAMS_COLOR)
                    end
                end
                task.wait(1)
            end
        end)
    end
end

-- Remove chams from a character
local function removeChams(character)
    for _, child in pairs(character:GetDescendants()) do
        if child:IsA("Highlight") then
            child:Destroy()
        end
    end
end

-- Revert chams on all NPCs regardless of position
local function revertNPCChams()
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("Model") and isNPC(descendant) then
            removeChams(descendant)
        end
    end
end

-- Toggle blue chams for NPCs above the Y threshold
-- File: scripts/toggle_npc_chams.lua

local function isAlive(model)
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health > 0 then
        return true
    end
    return false
end

local function onDeath(model)
    local highlight = model:FindFirstChildOfClass("Highlight")
    if highlight then
        highlight:Destroy()
    end
end

local function setupDeathListener(model)
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if humanoid and not humanoid:FindFirstChild("DeathListener") then
        local deathListener = Instance.new("BoolValue")
        deathListener.Name = "DeathListener"
        deathListener.Parent = humanoid
        humanoid.Died:Connect(function()
            onDeath(model)
        end)
    end
end

local function toggleNPCChams()
	local friendlies = game:GetService("Workspace"):FindFirstChild("activeFriendlies")

	for _, descendant in ipairs(workspace:GetDescendants()) do
		if descendant:IsA("Model") and isNPC(descendant) and isAboveThreshold(descendant, npcChamsThreshold) then
			if not isAlive(descendant) then
				continue
			end

			-- âŒ Skip if descendant is under activeFriendlies
			if friendlies and descendant:IsDescendantOf(friendlies) then
				continue
			end

			local rootPart = descendant:FindFirstChild("HumanoidRootPart")
			if rootPart and not isInNPCExclusionZone(rootPart.Position) then
				local existingChams = descendant:FindFirstChildOfClass("Highlight")
				if not existingChams then
					if descendant.Name == "AI_QUEEN" then
						local highlight = Instance.new("Highlight")
						highlight.Name = "QueenHighlight"
						highlight.Adornee = descendant
						highlight.FillColor = Color3.fromRGB(170, 0, 255)
						highlight.OutlineColor = Color3.fromRGB(158, 60, 214)
						highlight.FillTransparency = 1
						highlight.OutlineTransparency = 0.35
						highlight.Parent = descendant
					else
						applyChams(descendant, NPC_CHAMS_COLOR)
					end
					setupDeathListener(descendant)
				end
			end
		end
	end
end

-- Toggle green chams for players
local function togglePlayerChams()
    playerChamsEnabled = not playerChamsEnabled

    if playerChamsEnabled then
        playerChamsLoop = task.spawn(function()
            while playerChamsEnabled do
                for _, player in pairs(Players:GetPlayers()) do
                    if player.Character then
                        applyChams(player.Character, PLAYER_CHAMS_COLOR)
                    end
                end
                task.wait(1)
            end
        end)
    else
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                removeChams(player.Character)
            end
        end
        playerChamsLoop = nil
    end
end

-- UI Setup
screenGui = Instance.new("ScreenGui")
screenGui.Name = "HeadSizeEditor"
screenGui.Parent = game:GetService("CoreGui")
screenGui.Enabled = false

frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 200, 0, 120)
frame.Position = UDim2.new(0.5, -100, 0.4, -60)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 2
frame.Parent = screenGui

local textLabel = Instance.new("TextLabel")
textLabel.Text = "Enter Head Size:"
textLabel.Size = UDim2.new(1, 0, 0, 30)
textLabel.BackgroundTransparency = 1
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.Parent = frame

textBox = Instance.new("TextBox")
textBox.Size = UDim2.new(1, -10, 0, 30)
textBox.Position = UDim2.new(0, 5, 0, 35)
textBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
textBox.Text = tostring(HEAD_SIZE)
textBox.ClearTextOnFocus = false
textBox.Parent = frame

confirmButton = Instance.new("TextButton")
confirmButton.Size = UDim2.new(1, -10, 0, 30)
confirmButton.Position = UDim2.new(0, 5, 0, 75)
confirmButton.BackgroundColor3 = Color3.fromRGB(0, 145, 250)
confirmButton.TextColor3 = Color3.fromRGB(255, 255, 255)
confirmButton.Text = "Confirm"
confirmButton.BorderSizePixel = 2
confirmButton.BorderColor3 = Color3.fromRGB(0, 145, 250)
confirmButton.Parent = frame

local function toggleUI()
    guiOpen = not guiOpen
    if guiOpen then
        textBox.Text = tostring(HEAD_SIZE) -- Update box when opened
    end
    screenGui.Enabled = guiOpen
end

local function setHeadSize()
    local newSize = tonumber(textBox.Text)
    if newSize and newSize > 0 then
        uiHeadSize = newSize
        if not headOverrideEnabled then
            HEAD_SIZE = newSize
        end
    end
    toggleUI()
end

confirmButton.MouseButton1Click:Connect(setHeadSize)

-- Detect key presses
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    local isCtrl = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
    local isShift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

    -- Ctrl + Shift combo
    if isCtrl and isShift then
        if input.KeyCode == Enum.KeyCode.LeftBracket then
            togglePlayerChams() -- Ctrl + Shift + [
        elseif input.KeyCode == Enum.KeyCode.M then
            toggleUI() -- Ctrl + Shift + M â†’ toggle the head size editor UI
        end
        return
    end

    -- Shift + U combo (but not if Ctrl is held)
    if isShift and not isCtrl then
        if input.KeyCode == Enum.KeyCode.U then
            toggleNPCChamsThreshold() -- Shift + U â†’ toggle threshold between 40 and 80
        elseif input.KeyCode == Enum.KeyCode.LeftBracket then
            revertNPCChams()         --  Clear NPC outlines
            toggleNPCChams()         --  Reapply NPC outlines
        elseif input.KeyCode == Enum.KeyCode.RightBracket then
            applyNPCHeadSize() -- Shift + ]
        end
        return
    end

    -- Ctrl keybinds
    if isCtrl and not isShift then
        if input.KeyCode == Enum.KeyCode.LeftBracket then
            revertNPCChams() -- Ctrl + [
        elseif input.KeyCode == Enum.KeyCode.RightBracket then
            revertNPCHeadSize() -- Ctrl + ]
        elseif input.KeyCode == Enum.KeyCode.BackSlash then
            headOverrideEnabled = not headOverrideEnabled
            HEAD_SIZE = headOverrideEnabled and 27 or uiHeadSize
        end
    end
end)

startPlayerChamsLoop() -- correct: start loop if playerChamsEnabled is true


-- Path: StarterPlayerScripts/LinedAmmoDisplay.lua

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local function getRootPart()
	local char = player.Character or player.CharacterAdded:Wait()
	return char:WaitForChild("HumanoidRootPart")
end

local interactables = Workspace:WaitForChild("Interactables")

local orderedAmmoNames = {
    "Light Ammo",
    "Small Ammo",
    "Short Ammo",
    "Medium Ammo",
    "Heavy Ammo",
    "Long Ammo",
    "Shells Ammo"
}

local function anchorAllPartsIn(obj)
	if obj:IsA("Model") then
		for _, part in ipairs(obj:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = true
			end
		end
	elseif obj:IsA("BasePart") then
		obj.Anchored = true
	end
end

-- Add at top-level
local stackAmmoInLine = false

-- Updated exclusion zone corners
local exclusionCorner1 = Vector3.new(421.41, -3.39, -129.65)
local exclusionCorner2 = Vector3.new(252.23, -5.54, 108.89)

local function isInExclusionZone(pos: Vector3)
	local minX = math.min(exclusionCorner1.X, exclusionCorner2.X)
	local maxX = math.max(exclusionCorner1.X, exclusionCorner2.X)
	local minY = math.min(exclusionCorner1.Y, exclusionCorner2.Y)
	local maxY = math.max(exclusionCorner1.Y, exclusionCorner2.Y)
	local minZ = math.min(exclusionCorner1.Z, exclusionCorner2.Z)
	local maxZ = math.max(exclusionCorner1.Z, exclusionCorner2.Z)

	return pos.X >= minX and pos.X <= maxX and
	       pos.Y >= minY and pos.Y <= maxY and
	       pos.Z >= minZ and pos.Z <= maxZ
end

-- Modified placeAmmoWithSpacingAtPosition
-- Toggle-based behavior for ammo placement or remote pickup
local function placeAmmoWithSpacingAtPosition(position)
    local rootPart = getRootPart()
    local forward = rootPart.CFrame.LookVector
    local right = rootPart.CFrame.RightVector
    local facingRotation = CFrame.new(Vector3.zero, forward)

    local placed = 0
    local ammoStacks = {}
    for _, name in ipairs(orderedAmmoNames) do
        ammoStacks[name] = {}
    end

    for _, name in ipairs(orderedAmmoNames) do
        for _, instance in ipairs(interactables:GetChildren()) do
            if instance.Name == name then
                table.insert(ammoStacks[name], instance)
            end
        end
    end

    local exclusionMaxY = math.max(exclusionCorner1.Y, exclusionCorner2.Y)

    local Event = game:GetService("ReplicatedStorage").Interactables.interaction

    local teleportableAmmoStacks = {}
    for _, name in ipairs(orderedAmmoNames) do
        local stack = {}
        for _, instance in ipairs(ammoStacks[name]) do
            local isInside = false

            if instance:IsA("Model") then
                for _, part in ipairs(instance:GetDescendants()) do
                    if part:IsA("BasePart") and isInExclusionZone(part.Position) then
                        isInside = true
                        break
                    end
                end
            elseif instance:IsA("BasePart") and isInExclusionZone(instance.Position) then
                isInside = true
            end

            if not isInside then
                table.insert(stack, instance)
            end
        end
        if #stack > 0 then
            teleportableAmmoStacks[name] = stack
        end
    end

    local teleportNames = {}
    for _, name in ipairs(orderedAmmoNames) do
        if teleportableAmmoStacks[name] then
            table.insert(teleportNames, name)
        end
    end

    local ammoSpacing = {
        ["Light Ammo"] = 0.43,
        ["Small Ammo"] = 0.55,
        ["Short Ammo"] = 0.6,
        ["Medium Ammo"] = 0.75,
        ["Heavy Ammo"] = 0.74,
        ["Long Ammo"] = 0.89,
        ["Shells Ammo"] = 0.6
    }

    local totalOffset = 0
    for _, name in ipairs(teleportNames) do
        totalOffset += (ammoSpacing[name] or 0.5)
    end
    totalOffset -= (ammoSpacing[teleportNames[#teleportNames]] or 0.5)
    local lineOffset = -totalOffset / 2

    for _, name in ipairs(teleportNames) do
        local stack = teleportableAmmoStacks[name]
        local spacing = ammoSpacing[name] or 0.5
        local itemPos = position

        if stackAmmoInLine then
            itemPos = position + right * lineOffset
        end

        if isInExclusionZone(itemPos) then
            itemPos = Vector3.new(itemPos.X, exclusionMaxY + 0.6, itemPos.Z)
        end

        local rotation = facingRotation
        if name == "Heavy Ammo" then
            rotation *= CFrame.Angles(0, math.rad(90), 0)
        end

        for _, instance in ipairs(stack) do
            if stackAmmoInLine then
                local placeCF = CFrame.new(itemPos) * rotation

                if instance:IsA("Model") then
                    if not instance.PrimaryPart then
                        for _, p in ipairs(instance:GetChildren()) do
                            if p:IsA("BasePart") then
                                instance.PrimaryPart = p
                                break
                            end
                        end
                    end
                    if instance.PrimaryPart then
                        instance:PivotTo(placeCF)
                    end
                elseif instance:IsA("BasePart") then
                    instance.CFrame = placeCF
                end

                anchorAllPartsIn(instance)
                placed += 1
            else
                Event:FireServer(instance, "getAmmo")
                placed += 1
            end
        end

        if stackAmmoInLine then
            lineOffset += spacing
        end
    end

    print("ðŸ“¦", stackAmmoInLine and ("Placed " .. placed .. " ammo instances SIDE-BY-SIDE") or ("Picked up " .. placed .. " ammo instances via remote"))
end

-- Keybind handler for ammo placement
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	local ctrlHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
	local shiftHeld = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

	if input.KeyCode == Enum.KeyCode.L then
		local rootPart = getRootPart()
		local placePosition = rootPart.Position + rootPart.CFrame.LookVector * 3

		if ctrlHeld and not shiftHeld then
			stackAmmoInLine = true
			placeAmmoWithSpacingAtPosition(placePosition)
		elseif shiftHeld and not ctrlHeld then
			stackAmmoInLine = false
			placeAmmoWithSpacingAtPosition(placePosition)
		end
	end
end)








local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local weaponDrops = workspace:WaitForChild("WeaponDrops")
local camera = workspace.CurrentCamera

-- Exclusion zone setup
local exclusionCorner1 = Vector3.new(421.41, 1.3, -129.65)
local exclusionCorner2 = Vector3.new(252.23, -14.54, 108.89)

local includeToggleWeapons = {
    "pkillers", "ibup", "ssnare"
}

local includeToggleEnabled = false  -- Start with the toggle disabled, so these are excluded by default
local bpPrefixToggleEnabled = false  -- For Ctrl + I (bp prefix + extra)
local GrenadeToggleEnabled = false

local function isInExclusionZone(pos)
    local minX = math.min(exclusionCorner1.X, exclusionCorner2.X)
    local maxX = math.max(exclusionCorner1.X, exclusionCorner2.X)
    local minY = math.min(exclusionCorner1.Y, exclusionCorner2.Y)
    local maxY = math.max(exclusionCorner1.Y, exclusionCorner2.Y)
    local minZ = math.min(exclusionCorner1.Z, exclusionCorner2.Z)
    local maxZ = math.max(exclusionCorner1.Z, exclusionCorner2.Z)

    return pos.X >= minX and pos.X <= maxX and
           pos.Y >= minY and pos.Y <= maxY and
           pos.Z >= minZ and pos.Z <= maxZ
end

-- Excluded always (case-insensitive, all lowercase)
local excludedWeapons = {
    "rscythe", "taxe", 
    "crbandage", "chammer", "pfork", "tcaltrop", "crwoods", 
    "splint", "bbat", "lpipe", "adbandage", 
    "tourni", "karamb", "crpavise", 
    "scknife", "ptrap", "pspear", "thawk", "shovel", "cbar", "pcutter", "yari", "dmusket",
    "paxe", "rake", "badbat", "ipick", "bspear", "fpan", "mfork", "rbow", "crbow", "tspear", "nailedb", "dfaxe",
    "rpier", "ccleaver", "hknife", "ssword", "cflag", "cknife", "pbaton", "saxe", "mmachete", "milaxe", "tjavelin", "crbranch", "eflag", "nsword", "esword", "crstone"
}

-- These are excluded by default, but included when toggle is ON
local ctrlUToggleWeapons = { "pkillers", "ibup", "spdstim", "defstim", "maid", "hstim", "sstim", "faid" } -- group for Ctrl+U
local ctrlIToggleWeapons = { "pmine", "ssnare" } -- group for Ctrl+I
local ctrlshiftoToggleWeapons = { "impn", "dynamite", "molo", "mgrenade", "rexplosive" }-- group for Ctrl+Shift+O

-- Toggle state
local includeToggleEnabled = false

local function isWeaponExcluded(name)
    local lowerName = string.lower(name)

    -- Always excluded list
    for _, exclude in ipairs(excludedWeapons) do
        if lowerName == exclude then return true end
    end

    -- Always exclude anything ending in "stim"
    if lowerName:sub(-4) == "stim" then
        if not table.find(ctrlUToggleWeapons, lowerName) or not includeToggleEnabled then
            return true
        end
    end

    -- "bp" prefixed handling
    if lowerName:sub(1, 2) == "bp" then
        if lowerName == "bpack" then
            return false
        elseif not bpPrefixToggleEnabled then
            return true
        end
    end

    -- Include group: Ctrl+U toggle
    for _, weapon in ipairs(ctrlUToggleWeapons) do
        if lowerName == weapon then
            return not includeToggleEnabled
        end
    end

    -- Include group: Ctrl+Shift+O toggle
    for _, weapon in ipairs(ctrlshiftoToggleWeapons) do
        if lowerName == weapon then
            return not GrenadeToggleEnabled
        end
    end

    -- Include group: Ctrl+Y toggle
    for _, weapon in ipairs(ctrlIToggleWeapons) do
        if lowerName == weapon then
            return not bpPrefixToggleEnabled
        end
    end

    return false
end

-- Billboard creation
local function createBillboard(model)
    if model:FindFirstChild("WeaponLabel") then return end

    local headPart = model:FindFirstChildWhichIsA("BasePart")
    if not headPart then return end

    local gui = Instance.new("BillboardGui")
    gui.Name = "WeaponLabel"
    gui.Size = UDim2.new(0, 120, 0, 30)
    gui.StudsOffset = Vector3.new(0, 2.5, 0)
    gui.AlwaysOnTop = true
    gui.MaxDistance = math.huge
    gui.Adornee = headPart
    gui.Parent = model

    local label = Instance.new("TextLabel")
    label.Name = "Label"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(0, 145, 250)  -- Change color to (0, 145, 250)
    label.TextStrokeTransparency = 0.4

    local modelName = model.Name:lower()  -- Use lowercase for case-insensitive comparisons
    if modelName == "ibup" then
        label.Text = "Pills" -- Rename if it's "ibup"
    elseif modelName == "pkillers" then
        label.Text = "Tablets" -- Rename if it's "pkillers"
    elseif modelName == "maid" then
        label.Text = "Medkit"  -- Rename if it's "supak"
    elseif modelName == "faid" then
        label.Text = "IFAK"  -- Rename if it's "supak"
    elseif modelName == "supak" then
        label.Text = "M.AKM"  -- Rename if it's "supak"
    elseif modelName == "svd" then
        label.Text = "Dragunov"  -- Rename if it's "svd"
    elseif modelName == "subvector" then
        label.Text = "KRISSVector"  -- Rename if it's "subvector"
    elseif modelName == "sks" then
        label.Text = "Simonov"  -- Rename 
    elseif modelName == "mrvolver" then
        label.Text = "REDEEMER"  -- Rename 
    elseif modelName == "spshotgun" then
        label.Text = "SPAS-12"  -- Rename
    elseif modelName == "mauser" then
        label.Text = "SH.Dolch-96"  -- Rename
    elseif modelName == "hstim" then
        label.Text = "C.Stim"  -- Rename 
    elseif modelName == "subscar" then
        label.Text = "SCARH"  -- Rename 
    elseif modelName == "supmpistol" then
        label.Text = "M.PistolS"  -- Rename 
    elseif modelName == "pistol" then
        label.Text = "BroomHandle"  -- Rename 
    elseif modelName == "tsmg" then
        label.Text = "Tommy Gun"  -- Rename 
    elseif modelName == "bpack" then
        label.Text = "Backpack"  -- Rename 
    elseif modelName == "defstim" then
        label.Text = "I4S.Stim"  -- Rename 
    elseif modelName == "sstim" then
        label.Text = "BL1.Stim"  -- Rename
    elseif modelName == "spdstim" then
        label.Text = "S.Stim"  -- Rename 
    elseif modelName == "stipistol" then
        label.Text = "HiCapa"  -- Rename 
    elseif modelName == "bpsti" then
        label.Text = "BP.HiCapa"  -- Rename 
    elseif modelName == "apack" then
        label.Text = "T.Vest"  -- Rename 
    elseif modelName == "kshotgun" then
        label.Text = "K4shotgun"  -- Rename 
    elseif modelName == "urvolver" then
        label.Text = "H.Revolver"  -- Rename 
    elseif modelName == "crvolver" then
        label.Text = "ChainRevolver"  -- Rename 
   elseif modelName == "rvolver" then
        label.Text = "SH.Revolver"  -- Rename 
   elseif modelName == "submcx" then
        label.Text = "M.MCX"  -- Rename 
   elseif modelName == "submpx" then
        label.Text = "SIG.MPX"  -- Rename
   elseif modelName == "mgrenade" then
        label.Text = "G"  -- Rename
   elseif modelName == "impn" then
        label.Text = "Impact"  -- Rename
   elseif modelName == "molo" then
        label.Text = "Fire.B"  -- Rename
   elseif modelName == "submg" then
        label.Text = "S.CBJ-MS"  -- Rename
   elseif modelName == "mpten" then
        label.Text = "SH.MP5"  -- Rename
   elseif modelName == "subps" then
        label.Text = "P90"  -- Rename
   elseif modelName == "submp" then
        label.Text = "L.MP5"  -- Rename
   elseif modelName == "fnlmg" then
        label.Text = "M.FNLMG"  -- Rename
   elseif modelName == "intsniper" then
        label.Text = "Cheytac.M200"  -- Rename
   elseif modelName == "ebr" then
        label.Text = "M14.EBR"  -- Rename
   elseif modelName == "sublmg" then
        label.Text = "H.M60"  -- Rename
   elseif modelName == "hrifle" then
        label.Text = "Winchester1901-1"  -- Rename
   elseif modelName == "doubleshotgun" then
        label.Text = "Coldwell940Shotgun"  -- Rename
   elseif modelName == "subpp" then
        label.Text = "PPSH-41"  -- Rename
   elseif modelName == "mshotgun" then
        label.Text = "Model870Shotgun"  -- Rename
   elseif modelName == "amr" then
        label.Text = "PGM-FR"  -- Rename
   elseif modelName == "levershotgun" then
        label.Text = "Winchester1901Shotgun"  -- Rename
    elseif modelName == "mateba" then
        label.Text = "Model6Unico"  -- Rename if it's "mateba"
    else
        label.Text = model.Name
    end

    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.Parent = gui
end

-- Billboard logic
local function removeAllBillboards()
    for _, model in pairs(weaponDrops:GetChildren()) do
        if model:IsA("Model") then
            local existing = model:FindFirstChild("WeaponLabel")
            if existing then existing:Destroy() end
        end
    end
end

local function placeBillboards()
    for _, model in pairs(weaponDrops:GetChildren()) do
        if model:IsA("Model") and not isWeaponExcluded(model.Name) then
            local part = model:FindFirstChildWhichIsA("BasePart")
            if part then
                -- Check if the part is inside the exclusion zone
                if not isInExclusionZone(part.Position) then
                    -- If the part is not in the exclusion zone, create the billboard
                    createBillboard(model)
                else
                    -- If the part is in the exclusion zone, remove any existing billboard
                    local existingBillboard = model:FindFirstChild("WeaponLabel")
                    if existingBillboard then
                        existingBillboard:Destroy()
                    end
                end
            end
        end
    end
end

-- Dynamic resizing loop
RunService.RenderStepped:Connect(function()
    for _, model in pairs(weaponDrops:GetChildren()) do
        local gui = model:FindFirstChild("WeaponLabel")
        if gui and gui:IsA("BillboardGui") and gui.Adornee then
            local distance = (camera.CFrame.Position - gui.Adornee.Position).Magnitude
            local maxDistance = 600
            local minScale = 0.4
            local maxScale = 1
            local scale

            if distance >= maxDistance then
                scale = minScale  -- smallest size beyond 600 studs
            else
                -- linearly shrink from 1 to 0.4 between 0 and 600 studs
                scale = maxScale - (distance / maxDistance) * (maxScale - minScale)
            end

            gui.Size = UDim2.new(0, 120 * scale, 0, 30 * scale)
        end
    end
end)

-- Keybind logic
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    local isCtrl = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
    local isShift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

    -- Ctrl + M: Remove all billboards
    if input.KeyCode == Enum.KeyCode.M and isCtrl and not isShift then
        removeAllBillboards()
    end

    -- Shift + M: Reapply all billboards (remove then apply)
    if input.KeyCode == Enum.KeyCode.M and isShift and not isCtrl then
        removeAllBillboards()
        placeBillboards()
    end

    -- Ctrl + U: Toggle inclusion of toggleable weapons (like ibup, pkillers, sstim) and reapply billboards
    if input.KeyCode == Enum.KeyCode.U and isCtrl and not isShift then
        includeToggleEnabled = not includeToggleEnabled
        removeAllBillboards()
        placeBillboards()
    end

    -- Ctrl + Y: Toggle inclusion of 'bp'-prefixed weapons and reapply billboards
    if input.KeyCode == Enum.KeyCode.Y and isCtrl and not isShift then
        bpPrefixToggleEnabled = not bpPrefixToggleEnabled
        removeAllBillboards()
        placeBillboards()
    end
end)

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.O 
        and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) 
        and UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then

        GrenadeToggleEnabled = not GrenadeToggleEnabled
        removeAllBillboards()
        placeBillboards()
    end
end)




-- Fog Removal Script:
-- Ctrl + Shift + I: Toggle fog removal loop.
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local fogRemovalActive = false -- Tracks whether fog removal is active

-- Function to disable fog only
local function removeFog()
    -- Adjust fog properties to effectively disable it
    Lighting.FogEnd = 1e6 -- Set fog to an extremely far distance
    Lighting.FogStart = 1e6 -- Ensure the start of fog is far as well
end

-- Restore default fog settings
local function restoreFog()
    -- Adjust these values to your game's default fog settings
    Lighting.FogEnd = 1000 -- Default value (adjust to match your game)
    Lighting.FogStart = 0 -- Default value (adjust to match your game)
end

-- Toggle the fog removal loop
local function toggleFogRemoval()
    fogRemovalActive = not fogRemovalActive

    if fogRemovalActive then
        print("Fog removal enabled.")
    else
        print("Fog removal disabled.")
        restoreFog() -- Restore default fog settings when disabled
    end
end

-- Detect key presses for toggle, bypassing gameProcessed
UserInputService.InputBegan:Connect(function(input)
    -- Ctrl + Shift + I: Toggle fog removal
    if input.KeyCode == Enum.KeyCode.I and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        toggleFogRemoval()
    end
end)

-- Run fog removal every frame while active
RunService.Heartbeat:Connect(function()
    if fogRemovalActive then
        removeFog()
    end
end)



-- Multi-Workbench & Barrel ESP Script
-- Ctrl + Shift + L for Workbench, Ctrl + Shift + Y for Barrel

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

local espEnabledWorkbench = false
local espEnabledBarrel = false
local ESP_COLOR = Color3.fromRGB(0, 140, 250)
local BARREL_ESP_COLOR = Color3.fromRGB(255, 40, 40)
local espInstancesWorkbench = {}
local espInstancesBarrel = {}
local originalBarrelSizes = {}
local originalBarrelPositions = {}

local function findFirstBasePart(model)
    for _, descendant in ipairs(model:GetDescendants()) do
        if descendant:IsA("BasePart") then
            return descendant
        end
    end
    return nil
end

local function createESP(model, color)
    local part = findFirstBasePart(model)
    if not part then return nil end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESPOverlay_" .. model.Name
    billboard.Adornee = part
    billboard.Size = UDim2.new(3, 0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.LightInfluence = 0
    billboard.ResetOnSpawn = false
    billboard.Parent = playerGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundColor3 = color
    frame.BackgroundTransparency = 0.7
    frame.BorderSizePixel = 0
    frame.Parent = billboard

    return billboard
end

local function applyWorkbenchESP()
    for _, child in ipairs(Workspace.Interactables:GetChildren()) do
        if child:IsA("Model") and child.Name == "Workbench" and not espInstancesWorkbench[child] then
            local esp = createESP(child, ESP_COLOR)
            if esp then
                espInstancesWorkbench[child] = esp
            end
        end
    end
end

local function removeWorkbenchESP()
    for model, esp in pairs(espInstancesWorkbench) do
        if esp then esp:Destroy() end
    end
    table.clear(espInstancesWorkbench)
end

local function applyBarrelESP()
    for _, child in ipairs(Workspace.Interactables:GetChildren()) do
        if child:IsA("Model") and child.Name == "Barrel" and not espInstancesBarrel[child] then
            -- Apply the ESP
            local esp = createESP(child, BARREL_ESP_COLOR)
            if esp then
                espInstancesBarrel[child] = esp
            end

            -- Store the original size and position
            for _, part in ipairs(child:GetDescendants()) do
                if part:IsA("BasePart") then
                    originalBarrelSizes[part] = part.Size
                    originalBarrelPositions[part] = part.Position

                    -- Modify size: 5x wider and deeper, 10x taller
                    local newWidth = part.Size.X * 5
                    local newHeight = part.Size.Y * 10  -- 10 times taller
                    local newDepth = part.Size.Z * 5

                    part.Size = Vector3.new(newWidth, newHeight, newDepth)

                    -- Move the barrel upwards (to avoid it extending downwards)
                    local offsetY = part.Size.Y - originalBarrelSizes[part].Y  -- Calculate the offset to move the part upwards
                    part.Position = part.Position + Vector3.new(0, offsetY, 0)

                    -- Freeze the position of the ESP's billboard
                    if esp then
                        esp.Adornee = part
                    end
                end
            end
        end
    end
end

local function removeBarrelESP()
    for model, esp in pairs(espInstancesBarrel) do
        if esp then esp:Destroy() end
    end
    for part, size in pairs(originalBarrelSizes) do
        if part and part:IsA("BasePart") then
            part.Size = size
        end
    end
    for part, position in pairs(originalBarrelPositions) do
        if part and part:IsA("BasePart") then
            part.Position = position
        end
    end
    table.clear(espInstancesBarrel)
    table.clear(originalBarrelSizes)
    table.clear(originalBarrelPositions)
end

local function toggleWorkbenchESP()
    espEnabledWorkbench = not espEnabledWorkbench
    if espEnabledWorkbench then
        applyWorkbenchESP()
    else
        removeWorkbenchESP()
    end
end

local function toggleBarrelESP()
    espEnabledBarrel = not espEnabledBarrel
    if espEnabledBarrel then
        applyBarrelESP()
    else
        removeBarrelESP()
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == Enum.KeyCode.L and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        toggleWorkbenchESP()
    end

    if input.KeyCode == Enum.KeyCode.Y and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        toggleBarrelESP()
    end
end)





-- File: StarterPlayerScripts/AutoTpWalk.lua

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildWhichIsA("Humanoid")

local tpwalking = true  -- Automatically enable teleport walking
local tpwalkSpeed = 0.34 -- Default speed
local uiEnabled = false
local screenGui, frame, textBox, confirmButton
local tpWalkConnection

local function startTpWalk()
    tpwalking = true

    if tpWalkConnection then
        tpWalkConnection:Disconnect()
    end

    tpWalkConnection = RunService.Heartbeat:Connect(function(delta)
        local chr = player.Character
        local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
        if tpwalking and chr and hum and hum.Parent then
            if hum.MoveDirection.Magnitude > 0 then
                chr:TranslateBy(hum.MoveDirection * tpwalkSpeed * delta * 10)
            end
        end
    end)
end

local function stopTpWalk()
    tpwalking = false
    if tpWalkConnection then
        tpWalkConnection:Disconnect()
        tpWalkConnection = nil
    end
end

local function toggleTpWalk()
    if tpwalking then
        stopTpWalk()
    else
        startTpWalk()
    end
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:FindFirstChildWhichIsA("Humanoid")

    if tpwalking then
        task.wait(1)
        startTpWalk()
    end
end

player.CharacterAdded:Connect(onCharacterAdded)

local function createSpeedUI()
    if screenGui then return end

    screenGui = Instance.new("ScreenGui")
    screenGui.ResetOnSpawn = false
    screenGui.Parent = player:WaitForChild("PlayerGui")

    frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 230, 0, 150)
    frame.Position = UDim2.new(0.5, -115, 0.5, -75)
    frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(100, 180, 255)
    frame.Parent = screenGui

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0.2, 0)
    titleLabel.Position = UDim2.new(0, 0, 0, 5)
    titleLabel.Text = "Change Speed"
    titleLabel.TextColor3 = Color3.fromRGB(0, 145, 250)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = 20
    titleLabel.Parent = frame

    textBox = Instance.new("TextBox")
    textBox.Size = UDim2.new(0.8, 0, 0.3, 0)
    textBox.Position = UDim2.new(0.1, 0, 0.3, 0)
    textBox.PlaceholderText = "Enter speed"
    textBox.Text = tostring(tpwalkSpeed)
    textBox.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    textBox.ClearTextOnFocus = true
    textBox.TextColor3 = Color3.new(1, 1, 1)
    textBox.Parent = frame

    -- Filter input
    textBox:GetPropertyChangedSignal("Text"):Connect(function()
        local inputText = textBox.Text
        inputText = inputText:gsub("[^%d.]", "")
        local dotCount = select(2, inputText:gsub("%.", ""))
        if dotCount > 1 then
            inputText = inputText:sub(1, #inputText - 1)
        end
        textBox.Text = inputText
    end)

    textBox.FocusLost:Connect(function()
        if textBox.Text == "" or textBox.Text == "." then
            textBox.Text = tostring(tpwalkSpeed)
        end
    end)

    confirmButton = Instance.new("TextButton")
    confirmButton.Size = UDim2.new(0.8, 0, 0.3, 0)
    confirmButton.Position = UDim2.new(0.1, 0, 0.65, 0)
    confirmButton.Text = "Confirm"
    confirmButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    confirmButton.TextColor3 = Color3.new(1, 1, 1)
    confirmButton.Parent = frame

    confirmButton.MouseButton1Click:Connect(function()
        local newSpeed = tonumber(textBox.Text)
        if newSpeed and newSpeed > 0 then
            tpwalkSpeed = newSpeed
        end
        screenGui:Destroy()
        screenGui = nil
        uiEnabled = false
    end)
end

local function toggleSpeedUI()
    uiEnabled = not uiEnabled
    if uiEnabled then
        createSpeedUI()
    elseif screenGui then
        screenGui:Destroy()
        screenGui = nil
    end
end

-- No auto-start

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    local ctrl = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
    local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

    if input.KeyCode == Enum.KeyCode.P and ctrl and shift then
        toggleTpWalk()
    elseif input.KeyCode == Enum.KeyCode.U and ctrl and shift then
        toggleSpeedUI()
    end
end)

-- Automatically enable teleport walking without requiring a key press
startTpWalk()





local UserInputService = game:GetService("UserInputService")

-- Create UI
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = game.CoreGui
screenGui.Enabled = false

local keybindsFrame = Instance.new("Frame")
keybindsFrame.Size = UDim2.new(0, 270, 0, 720)  -- Increased height to fit additional keybind
keybindsFrame.Position = UDim2.new(1, -280, 0, -10)
keybindsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
keybindsFrame.BorderSizePixel = 2
keybindsFrame.BorderColor3 = Color3.fromRGB(0, 145, 250)
keybindsFrame.Parent = screenGui

local keybindsLabel = Instance.new("TextLabel")
keybindsLabel.RichText = true
keybindsLabel.Text = [[
<font color="rgb(0,185,45)">Decaying Winter: Made By Jonmaster1</font>
<p><font color="rgb(0,185,45)">Ctrl + Shift + L</font> <font color="rgb(120,175,255)">Toggle workbench esp</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + I</font> <font color="rgb(120,175,255)">Toggle Fog</font></p>
<p><font color="rgb(0,185,45)">Ctrl + U</font> <font color="rgb(120,175,255)">Enables the Item ESP to look for Tablets, Pills, Medkits, Speed stims, I4S Stims and IFAK</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Y</font> <font color="rgb(120,175,255)">Enables the Item ESP to look for Blueprints, Snare tripwire, Proximity mines and Remove Explosive (Trolling)</font></p>
<p><font color="rgb(0,185,45)">Shift + U</font> <font color="rgb(120,175,255)">Switches the NPC outline threshold from 40 to 100</font></p>
<p><font color="rgb(0,185,45)">Ctrl + [</font> <font color="rgb(120,175,255)">removes NPC outlines</font></p>
<p><font color="rgb(0,185,45)">Ctrl + ]</font> <font color="rgb(120,175,255)">removes NPC headsize</font></p>
<p><font color="rgb(0,185,45)">Shift + [</font> <font color="rgb(120,175,255)">Applies NPC outlines</font></p>
<p><font color="rgb(0,185,45)">Shift + ]</font> <font color="rgb(120,175,255)">Applies NPC headsize</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + [</font> <font color="rgb(120,175,255)">Toggles player outlines loop (ON by default)</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + ]</font> <font color="rgb(120,175,255)">Toggles SQ Headsize to lure out of castle and displays her health</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + M</font> <font color="rgb(120,175,255)">Opens the Headsize UI to change it</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + P</font> <font color="rgb(120,175,255)">Toggles TPwalkspeed (ON by default)</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + U</font> <font color="rgb(120,175,255)">Toggles Tpwalkspeed UI (default speed 0.34)</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + Y</font> <font color="rgb(120,175,255)">Toggles Barrel ESP (Increases Its Size For Trolling)</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + \</font> <font color="rgb(120,175,255)">Places Bilboards on Inactive Cameras (for Waveultima)</font></p>
<p><font color="rgb(0,185,45)">Ctrl + Shift + O</font> <font color="rgb(120,175,255)">Enables the Item ESP to look for Grenades to teamkill with</font></p>
<p><font color="rgb(0,185,45)">Ctrl + \</font> <font color="rgb(120,175,255)">Switches the headsize to 27 hit again to normalize</font></p>
<p><font color="rgb(0,185,45)">Shift + L</font> <font color="rgb(120,175,255)">Picks up all ammo Instanly</font></p>
<p><font color="rgb(0,185,45)">Ctrl + L</font> <font color="rgb(120,175,255)">Places all ammo Infront of you</font></p>
<p><font color="rgb(0,185,45)">Ctrl + M</font> <font color="rgb(120,175,255)">Removes the gun Bilboards (Item ESP)</font></p>
<p><font color="rgb(0,185,45)">Shift + M</font> <font color="rgb(120,175,255)">Places bilboards on all the lose guns on the map (Item ESP)</font></p>
<p><font color="rgb(0,185,45)">Shift + Y</font> <font color="rgb(120,175,255)">Toggles Keybinds UI</font></p>  <!-- New keybind added -->
]]
keybindsLabel.Size = UDim2.new(1, 0, 0, 690)  -- Increased size to fit the new keybind
keybindsLabel.Position = UDim2.new(0, 0, 0, 5)
keybindsLabel.BackgroundTransparency = 1
keybindsLabel.TextColor3 = Color3.fromRGB(120, 175, 255)
keybindsLabel.TextWrapped = true
keybindsLabel.TextScaled = false
keybindsLabel.Font = Enum.Font.SourceSansBold
keybindsLabel.TextSize = 17
keybindsLabel.Parent = keybindsFrame

local creditLabel = Instance.new("TextLabel")
creditLabel.Text = "Created by Jonmaster1"
creditLabel.Size = UDim2.new(1, 0, 0, 30)
creditLabel.Position = UDim2.new(0, 0, 0, 680)
creditLabel.BackgroundTransparency = 1
creditLabel.TextColor3 = Color3.fromRGB(0, 185, 45)
creditLabel.TextScaled = false
creditLabel.Font = Enum.Font.SourceSansBold
creditLabel.TextSize = 27
creditLabel.Parent = keybindsFrame


-- Make UI draggable
local dragging, dragInput, dragStart, startPos

keybindsFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = keybindsFrame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

keybindsFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        keybindsFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Toggle UI visibility with Shift + Y (Ctrl must NOT be held)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    -- Check if Shift + Y is pressed and Ctrl is NOT held
    if input.KeyCode == Enum.KeyCode.Y
    and UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
    and not UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
        screenGui.Enabled = not screenGui.Enabled
    end
end)



--!strict
-- File: QueenHeadEnhancer.lua

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

local toggled = false
local originalSize = nil
local revertTask = nil
local outlineHighlight = nil
local healthGui = nil
local healthGuiVisible = false
local renderBound = false

-- Helper: create/update health GUI
local healthGuiUpdateTask = nil

-- Helper: hide GUI
local function hideHealthGui()
	if healthGui then
		healthGui:Destroy()
		healthGui = nil
		healthGuiVisible = false
	end
	if healthGuiUpdateTask then
		healthGuiUpdateTask = nil
	end
end

local function createOrUpdateHealthGui(model, health, maxHealth, color)
	if not localPlayer or not playerGui then return end

	local gui = playerGui:FindFirstChild("QueenHealthGui")
	if not gui then
		gui = Instance.new("ScreenGui")
		gui.Name = "QueenHealthGui"
		gui.ResetOnSpawn = false
		gui.IgnoreGuiInset = true
		gui.Parent = playerGui

		-- Black outline text label
		local outlineText = Instance.new("TextLabel")
		outlineText.Name = "HealthTextOutline"
		outlineText.Size = UDim2.new(0, 150, 0, 50)
		outlineText.Position = UDim2.new(0.5, -75, 1, -133)
		outlineText.BackgroundTransparency = 1
		outlineText.TextColor3 = Color3.new(0, 0, 0)
		outlineText.Font = Enum.Font.SourceSansBold
		outlineText.TextScaled = true
		outlineText.TextStrokeTransparency = 0
		outlineText.TextStrokeColor3 = Color3.new(0, 0, 0)
		outlineText.ZIndex = 1
		outlineText.Parent = gui

		-- White main text label
		local mainText = Instance.new("TextLabel")
		mainText.Name = "HealthText"
		mainText.Size = UDim2.new(0, 150, 0, 50)
		mainText.Position = UDim2.new(0.5, -75, 1, -133)
		mainText.BackgroundTransparency = 1
		mainText.TextColor3 = color or Color3.fromRGB(158, 60, 214)
		mainText.Font = Enum.Font.SourceSansBold
		mainText.TextScaled = true
		mainText.ZIndex = 2
		mainText.Parent = gui

		healthGui = gui
		healthGuiVisible = true
	end

	local textLabel = gui:FindFirstChild("HealthText")
	local outlineLabel = gui:FindFirstChild("HealthTextOutline")
	if textLabel and outlineLabel then
		local humanoid = model and model:FindFirstChildOfClass("Humanoid")
		if not humanoid then return end

		-- Kill any previous update loop
		if healthGuiUpdateTask then
			healthGuiUpdateTask:Disconnect()
			healthGuiUpdateTask = nil
		end

		-- Loop to keep updating health every 0.5s
		healthGuiUpdateTask = task.spawn(function()
			while humanoid and humanoid.Parent and humanoid.Health > 0 and model and model.Parent do
				local healthText = tostring(math.floor(humanoid.Health))
				textLabel.Text = healthText
				outlineLabel.Text = healthText
				textLabel.TextColor3 = color or Color3.fromRGB(158, 60, 214)
				task.wait(0.5)
			end
			hideHealthGui()
		end)
	end
end

-- Helper: apply visual highlight
local function applyOutline(model: Model)
	if outlineHighlight then
		outlineHighlight:Destroy()
	end
	local highlight = Instance.new("Highlight")
	highlight.Name = "QueenHighlight"
	highlight.Adornee = model
	highlight.FillColor = Color3.fromRGB(170, 0, 255)
	highlight.OutlineColor = Color3.fromRGB(158, 60, 214)
	highlight.FillTransparency = 1
	highlight.OutlineTransparency = 0.35
	highlight.Parent = model
	outlineHighlight = highlight
end

-- Helper: revert visual and physical changes
-- Helper: revert visual and physical changes
local function revertChanges(head: BasePart)
    if originalSize then
        head.Size = originalSize
        print("âœ… Reverted head to original size:", originalSize)
        originalSize = nil
    else
        print("âš ï¸ No original size cached, cannot revert head size")
    end

    if outlineHighlight then
        outlineHighlight:Destroy()
        outlineHighlight = nil
    end

    hideHealthGui()

    toggled = false
    revertTask = nil

    print("â³ Auto-reverted Queen head and outline")
end

-- Coroutine-based timeout revert task
local function startRevertTimer(head: BasePart, model: Model, humanoid: Humanoid)
    if revertTask then
        coroutine.close(revertTask)
        revertTask = nil
    end

    revertTask = coroutine.create(function()
        task.wait(150)

        if toggled and head and head.Parent then
            revertChanges(head)
        end

        if humanoid and humanoid.Health <= 0 then
            RunService:UnbindFromRenderStep("UpdateQueenHealth")
            renderBound = false
            hideHealthGui()
        end

        if proximityCheckTask then
            proximityCheckTask:Disconnect()
            proximityCheckTask = nil
        end

        revertTask = nil
    end)

    coroutine.resume(revertTask)
end

-- Hotkey toggle
local touchConnection = nil

-- Hotkey toggle
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	local ctrlDown = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
	local shiftDown = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

	if input.KeyCode == Enum.KeyCode.RightBracket and ctrlDown and shiftDown then
		local model = Workspace:FindFirstChild("activeHostiles") and Workspace.activeHostiles:FindFirstChild("AI_QUEEN")
		local head = model and model:FindFirstChild("Head")
		local humanoid = model and model:FindFirstChildOfClass("Humanoid")

		if model and head and humanoid then
			head.CanCollide = false
			head.Transparency = 1
			head.Massless = true

			if touchConnection then
				touchConnection:Disconnect()
				touchConnection = nil
			end

			if not toggled then
				if not originalSize then
					originalSize = head.Size
				end

				head.Size = Vector3.new(45, 200, 45)
				toggled = true
				applyOutline(model)
				print("ðŸŸ£ SQhead Sized 200 and outlined")

				createOrUpdateHealthGui(model, humanoid.Health, humanoid.MaxHealth, outlineHighlight and outlineHighlight.OutlineColor or Color3.fromRGB(158, 60, 214))

				if not renderBound then
					renderBound = true
					RunService:BindToRenderStep("UpdateQueenHealth", Enum.RenderPriority.Last.Value, function()
						if humanoid.Health <= 0 then
							RunService:UnbindFromRenderStep("UpdateQueenHealth")
							renderBound = false
							hideHealthGui()
						end
					end)
				end

				if proximityCheckTask then
					proximityCheckTask:Disconnect()
				end

				proximityCheckTask = task.spawn(function()
					while toggled and head and head.Parent do
						local character = localPlayer and localPlayer.Character
						local hrp = character and character:FindFirstChild("HumanoidRootPart")
						if hrp then
							local distance = (head.Position - hrp.Position).Magnitude
							if distance <= 55 then
								if revertTask then
									coroutine.close(revertTask)
									revertTask = nil
								end

								revertChanges(head)
								createOrUpdateHealthGui(model, humanoid.Health, humanoid.MaxHealth, Color3.fromRGB(158, 60, 214))
								break
							end
						end
						task.wait(0.5)
					end
				end)

				startRevertTimer(head, model, humanoid)
			else
				if revertTask then
					coroutine.close(revertTask)
					revertTask = nil
				end

				revertChanges(head)
				RunService:UnbindFromRenderStep("UpdateQueenHealth")
				renderBound = false
				hideHealthGui()
			end
		else
			StarterGui:SetCore("SendNotification", {
				Title = "AI_QUEEN Head Not Found",
				Text = "Could not find AI_QUEEN.Head in Workspace.",
				Duration = 3
			})

			toggled = false
			originalSize = nil

			if revertTask then
				coroutine.close(revertTask)
				revertTask = nil
			end

			if proximityCheckTask then
				proximityCheckTask:Disconnect()
				proximityCheckTask = nil
			end

			RunService:UnbindFromRenderStep("UpdateQueenHealth")
			renderBound = false
			hideHealthGui()
			print("âŒ REVERT FAILED - Head not found. Resetting state.")
		end
	end
end)






--!strict

local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local billboardToggled = false
local billboardName = "PurpleLensBillboard"
local force = false -- set to true to bypass color checks

local function isDarkColor(color: Color3): boolean
	local brightness = (color.R + color.G + color.B) / 3
	return brightness < 0.25
end

local function isGreenDominant(color: Color3): boolean
	return color.G > color.R + 0.1 and color.G > color.B + 0.1
end

local function createBillboard(part: BasePart)
	if part:FindFirstChild(billboardName) then return end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = billboardName
	billboard.Adornee = part
	billboard.Size = UDim2.new(0, 20, 0, 20)
	billboard.AlwaysOnTop = true
	billboard.StudsOffset = Vector3.new(0, 2, 0)
	billboard.ResetOnSpawn = false

	local frame = Instance.new("Frame")
	frame.Name = "Frame"
	frame.Size = UDim2.new(3, 0, 3, 0)
	frame.BackgroundColor3 = Color3.fromRGB(158, 60, 214)
	frame.BackgroundTransparency = 0.7
	frame.BorderSizePixel = 0
	frame.Parent = billboard

	billboard.Parent = part
end

local function updateBillboardSizes()
	local player = Players.LocalPlayer
	if not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
	local hrp = player.Character.HumanoidRootPart

	local cameras = Workspace:FindFirstChild("InteractablesNoDel")
		and Workspace.InteractablesNoDel:FindFirstChild("WaveultimaQuest")
		and Workspace.InteractablesNoDel.WaveultimaQuest:FindFirstChild("Cameras")
	if not cameras then return end

	for _, camera in ipairs(cameras:GetChildren()) do
		if camera:IsA("Model") then
			local cam = camera:FindFirstChild("cam")
			local lens = cam and cam:FindFirstChild("Lens")

			if lens and lens:IsA("BasePart") then
				local bb = lens:FindFirstChild(billboardName)
				if bb and bb:IsA("BillboardGui") then
					local distance = (hrp.Position - lens.Position).Magnitude
					local scale = math.clamp(1 - (distance / 600), 0.4, 1)
					bb.Size = UDim2.new(0, 20 * scale, 0, 20 * scale)
				end
			end
		end
	end
end

local function clearBillboards()
	local cameras = Workspace:FindFirstChild("InteractablesNoDel")
		and Workspace.InteractablesNoDel:FindFirstChild("WaveultimaQuest")
		and Workspace.InteractablesNoDel.WaveultimaQuest:FindFirstChild("Cameras")

	if not cameras then return end

	for _, camera in ipairs(cameras:GetChildren()) do
		if camera:IsA("Model") then
			local cam = camera:FindFirstChild("cam")
			local lens = cam and cam:FindFirstChild("Lens")

			if lens and lens:IsA("BasePart") then
				local bb = lens:FindFirstChild(billboardName)
				if bb and bb:IsA("BillboardGui") then
					bb:Destroy()
				end
			end
		end
	end
end

local function placeBillboards()
	local cameras = Workspace:FindFirstChild("InteractablesNoDel")
		and Workspace.InteractablesNoDel:FindFirstChild("WaveultimaQuest")
		and Workspace.InteractablesNoDel.WaveultimaQuest:FindFirstChild("Cameras")

	if not cameras then return end

	for _, camera in ipairs(cameras:GetChildren()) do
		if camera:IsA("Model") then
			local cam = camera:FindFirstChild("cam")
			local lens = cam and cam:FindFirstChild("Lens")

			if lens and lens:IsA("BasePart") then
				local color = lens.Color
				if force or (isDarkColor(color) and not isGreenDominant(color)) then
					createBillboard(lens)
				end
			end
		end
	end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end

	local ctrlDown = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
	local shiftDown = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)

	if input.KeyCode == Enum.KeyCode.BackSlash and ctrlDown and shiftDown then
		billboardToggled = not billboardToggled
		if billboardToggled then
			placeBillboards()
		else
			clearBillboards()
		end
	end
end)

RunService.RenderStepped:Connect(function()
	if billboardToggled then
		updateBillboardSizes()
	end
end)




loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
