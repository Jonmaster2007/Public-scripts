-- =====================================================
--  UNIVERSAL WAYPOINT TWEEN FUNCTION (Safe Tween)
--  ✔ FULL 3D MOVEMENT (no more forced horizontal)
-- =====================================================

-- Your defaults (only applied once when script loads)
getgenv().antiDamageEnabled = (getgenv().antiDamageEnabled ~= nil) and getgenv().antiDamageEnabled or true
getgenv().blockRagdoll = (getgenv().blockRagdoll ~= nil) and getgenv().blockRagdoll or false

getgenv().TweenToPosition = function(positionVector3)
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local player = Players.LocalPlayer
    if not player then return end

    local char = player.Character
    if not char then warn("TweenToPosition: character not loaded yet") return end

    local root = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
    if not root then warn("TweenToPosition: no PrimaryPart or HRP") return end

    if typeof(positionVector3) ~= "Vector3" then
        warn("TweenToPosition: invalid Vector3")
        return
    end

    -- Distance → duration
    local distance = (positionVector3 - root.Position).Magnitude
    local TIME_PER_STUD = 1 / 150
    local duration = math.clamp(distance * TIME_PER_STUD, 0.1, 10)

    -- Save BOTH user settings
    local originalRagdollState = getgenv().blockRagdoll
    local originalAntiDmgState = getgenv().antiDamageEnabled

    -- Force protection ON during teleport
    getgenv().blockRagdoll = true
    getgenv().antiDamageEnabled = true

    -- Tween the entire character model via PrimaryPart
    local tween = TweenService:Create(
        root,
        TweenInfo.new(duration, Enum.EasingStyle.Linear),
        {CFrame = CFrame.new(positionVector3)}
    )
    tween:Play()

    tween.Completed:Connect(function()
        task.delay(1, function()
            -- Restore the user's settings after 1 second
            getgenv().blockRagdoll = originalRagdollState
            getgenv().antiDamageEnabled = originalAntiDmgState
        end)
    end)
end




-- ======= ROBUST NEAREST HELPERS (separate, no impact on tween) =======

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

local function getHRP()
    local char = localPlayer and localPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function chooseBestPartFromModel(model)
    if not model then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then
        return model.PrimaryPart
    end
    local commonNames = {"Base","Lid","Cylinder","Place","OpenLootTable","Root","Handle"}
    for _, name in ipairs(commonNames) do
        local part = model:FindFirstChild(name, true)
        if part and part:IsA("BasePart") then
            return part
        end
    end
    return model:FindFirstChildWhichIsA("BasePart", true)
end

-- GET NEAREST AIRDROP (returns the exact Crate part used by ESP)
getgenv().GetNearestAirdrop = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, ad in ipairs(debris:GetChildren()) do
        if ad.Name == "Airdrop" then
            local drop = ad:FindFirstChild("Drop")
            if drop then
                local crate = drop:FindFirstChild("Crate")
                if crate then
                    local part = crate:IsA("BasePart") and crate or crate.PrimaryPart or crate:FindFirstChildWhichIsA("BasePart")
                    if part then
                        local dist = (part.Position - hrp.Position).Magnitude
                        if dist < distMin then
                            nearest, distMin = part, dist
                        end
                    end
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST DRONE LOOT (returns the exact part used by ESP)
getgenv().GetNearestDroneLoot = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local lootFolder = debris:FindFirstChild("Loot")
    if not lootFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, loot in ipairs(lootFolder:GetChildren()) do
        if loot.Name == "DroneLoot" then
            local primary = loot.PrimaryPart or loot:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST TERMINAL (explicitly from workspace.Terminals)
getgenv().GetNearestTerminal = function()
    local terminalsFolder = workspace:FindFirstChild("Terminals")
    if not terminalsFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, terminal in ipairs(terminalsFolder:GetChildren()) do
        if terminal:IsA("Model") then
            local primary = terminal.PrimaryPart or terminal:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        elseif terminal:IsA("BasePart") then
            local dist = (terminal.Position - hrp.Position).Magnitude
            if dist < distMin then
                nearest, distMin = terminal, dist
            end
        end
    end

    return nearest
end

-- TELEPORT 3 STUDS ABOVE TARGET PART OR MODEL
getgenv().TeleportAbove = function(target)
    if not target then return end

    local position
    if target:IsA("BasePart") then
        position = target.Position + Vector3.new(0, 3, 0)
    elseif target:IsA("Model") then
        local primary = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
        if primary then
            position = primary.Position + Vector3.new(0, 3, 0)
        end
    end

    if position then
        getgenv().TweenToPosition(position)
    end
end
