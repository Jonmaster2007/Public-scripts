-- =====================================================
--  UNIVERSAL WAYPOINT TWEEN FUNCTION (Safe Tween)
--  ✔ FULL 3D MOVEMENT (no more forced horizontal)
-- =====================================================

getgenv()._tweenActiveCount = 0
getgenv()._savedOriginal = nil

_G.undergroundTweenEnabled = true

-- Forbidden Zone (A and B corners)
local ZoneA = Vector3.new(789, 44, -848)
local ZoneB = Vector3.new(411, -10, -1338)

local ZoneMin = Vector3.new(
    math.min(ZoneA.X, ZoneB.X),
    math.min(ZoneA.Y, ZoneB.Y),
    math.min(ZoneA.Z, ZoneB.Z)
)

local ZoneMax = Vector3.new(
    math.max(ZoneA.X, ZoneB.X),
    math.max(ZoneA.Y, ZoneB.Y),
    math.max(ZoneA.Z, ZoneB.Z)
)

local PADDING = 4 -- studs

local function pointInsideZone(v)
    return (
        v.X >= ZoneMin.X and v.X <= ZoneMax.X and
        v.Y >= ZoneMin.Y and v.Y <= ZoneMax.Y and
        v.Z >= ZoneMin.Z and v.Z <= ZoneMax.Z
    )
end

local function local thisTween = tick()
getgenv()._lastTweenFinish = thisTween

task.delay(1, function()
    -- If a newer tween finished, ignore this restore
    if getgenv()._lastTweenFinish ~= thisTween then return end

    getgenv()._tweenActiveCount -= 1

    -- Only restore when NO tweens remain
    if getgenv()._tweenActiveCount == 0 then
        if getgenv()._savedOriginal then
            getgenv().blockRagdoll = getgenv()._savedOriginal.ragdoll
            getgenv().antiDamageEnabled = getgenv()._savedOriginal.anti
        end
        getgenv()._savedOriginal = nil
    end
end)

    getgenv()._pendingRestore = {
        ragdoll = originalRagdoll,
        anti = originalAntiDmg,
        time = tick()
    }

    local thisRestore = getgenv()._pendingRestore

    task.delay(1, function()
        if getgenv()._pendingRestore == thisRestore then
            getgenv().blockRagdoll = thisRestore.ragdoll
            getgenv().antiDamageEnabled = thisRestore.anti
        end
    end)
end

-- Default settings
getgenv().antiDamageEnabled = (getgenv().antiDamageEnabled ~= nil) and getgenv().antiDamageEnabled or true
getgenv().blockRagdoll = (getgenv().blockRagdoll ~= nil) and getgenv().blockRagdoll or false

-- =====================================================
--  ADVANCED TWEEN SYSTEM WITH PATHFIND AROUND ZONE
-- =====================================================

getgenv().NormalTweenToPosition = function(targetPos)
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local player = Players.LocalPlayer
    if not player then return end

    local char = player.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if typeof(targetPos) ~= "Vector3" then return end

    -- Only save original values if this is the first tween
    
    if getgenv()._tweenActiveCount == 0 then
    
        getgenv()._savedOriginal = {
    
            ragdoll = getgenv().blockRagdoll,
    
            anti = getgenv().antiDamageEnabled
    
        }
    
    end

    getgenv()._tweenActiveCount += 1

    -- Force protection ON during tween
    getgenv().blockRagdoll = true
    getgenv().antiDamageEnabled = true


    local dist = (targetPos - root.Position).Magnitude
    local duration = math.clamp(dist * (1/150), 0.1, 10)

    local tween = TweenService:Create(
        root,
        TweenInfo.new(duration, Enum.EasingStyle.Linear),
        {CFrame = CFrame.new(targetPos)}
    )
    tween:Play()
    tween.Completed:Wait()

    local thisTween = tick()
    getgenv()._lastTweenFinish = thisTween

    task.delay(1, function()
        -- If a newer tween finished, ignore this restore
        if getgenv()._lastTweenFinish ~= thisTween then return end

        getgenv()._tweenActiveCount -= 1

        -- Only restore when NO tweens remain
        if getgenv()._tweenActiveCount == 0 then
            if getgenv()._savedOriginal then
                getgenv().blockRagdoll = getgenv()._savedOriginal.ragdoll
                getgenv().antiDamageEnabled = getgenv()._savedOriginal.anti
            end
            getgenv()._savedOriginal = nil
        end
    end)


end




_G.ForceNormalTween = function(pos)
    if getgenv().NormalTweenToPosition then
        getgenv().NormalTweenToPosition(pos)
    else
        getgenv().TweenToPosition(pos)
    end
end


getgenv().TweenToPosition = function(targetPos)
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local player = Players.LocalPlayer
    if not player then return end

    local char = player.Character
    if not char then warn("TweenToPosition: character not loaded yet") return end

    local root = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
    if not root then warn("TweenToPosition: no HRP") return end

    if typeof(targetPos) ~= "Vector3" then
        warn("TweenToPosition: invalid Vector3")
        return
    end

    -- Save original protection states
    -- Only save original values if this is the first tween
    if getgenv()._tweenActiveCount == 0 then
        getgenv()._savedOriginal = {
            ragdoll = getgenv().blockRagdoll,
            anti = getgenv().antiDamageEnabled
        }
    end

    getgenv()._tweenActiveCount += 1

    -- Force protection ON during tween
    getgenv().blockRagdoll = true
    getgenv().antiDamageEnabled = true


    local function doTween(goalPos)
        local dist = (goalPos - root.Position).Magnitude
        local t = math.clamp(dist * (1/150), 0.1, 10)

        local tween = TweenService:Create(
            root,
            TweenInfo.new(t, Enum.EasingStyle.Linear),
            {CFrame = CFrame.new(goalPos)}
        )
        tween:Play()
        tween.Completed:Wait()
    end

    ---------------------------------------------------------
    -- MODE A — NORMAL DIRECT TWEEN (no underground)
    ---------------------------------------------------------
    if not _G.undergroundTweenEnabled then
        getgenv().NormalTweenToPosition(targetPos)

    else
    ---------------------------------------------------------
    -- MODE B — ADVANCED UNDERGROUND WITH ZONE AVOIDANCE
    ---------------------------------------------------------
        local startPos = root.Position

        -- determine descent Y
        local downY
        if startPos.Y >= 37 then
            downY = 25
        else
            downY = startPos.Y - 12
        end

        local neededTargetDown = targetPos.Y - 12
        if downY > neededTargetDown then
            downY = neededTargetDown
        end

        local downPos = Vector3.new(startPos.X, downY, startPos.Z)
        local horizontalY = downY
        local upPos = targetPos

        local function segmentIntersectsZone(a, b)
            local dir = b - a
            local tMin = 0
            local tMax = 1

            local function axisCheck(axis, minB, maxB)
                local origin = a[axis]
                local direction = dir[axis]

                if math.abs(direction) < 1e-6 then
                    return origin >= minB and origin <= maxB
                end

                local t1 = (minB - origin) / direction
                local t2 = (maxB - origin) / direction
                if t1 > t2 then t1, t2 = t2, t1 end

                if t2 < tMin or t1 > tMax then
                    return false
                end

                if t1 > tMin then tMin = t1 end
                if t2 < tMax then tMax = t2 end
                return true
            end

            return
                axisCheck("X", ZoneMin.X - PADDING, ZoneMax.X + PADDING) and
                axisCheck("Y", ZoneMin.Y - PADDING, ZoneMax.Y + PADDING) and
                axisCheck("Z", ZoneMin.Z - PADDING, ZoneMax.Z + PADDING)
        end

        local horizStart = downPos
        local horizEnd   = Vector3.new(targetPos.X, horizontalY, targetPos.Z)

        local horizontalHitsZone =
            segmentIntersectsZone(horizStart, horizEnd)

        doTween(downPos)

        if horizontalHitsZone and not pointInsideZone(targetPos) then
            -- goes fully under zone
            local safeY = ZoneMin.Y - 10
            doTween(Vector3.new(startPos.X, safeY, startPos.Z))
            doTween(Vector3.new(targetPos.X, safeY, targetPos.Z))
        else
            -- safe straight horizontal
            doTween(Vector3.new(targetPos.X, horizontalY, targetPos.Z))
        end

        doTween(upPos)
    end

    -- Restore both protections & UI after tween
    local thisTween = tick()
    getgenv()._lastTweenFinish = thisTween

    task.delay(1, function()
        -- If a newer tween finished, ignore this restore
        if getgenv()._lastTweenFinish ~= thisTween then return end

        getgenv()._tweenActiveCount -= 1

        -- Only restore when NO tweens remain
        if getgenv()._tweenActiveCount == 0 then
            if getgenv()._savedOriginal then
                getgenv().blockRagdoll = getgenv()._savedOriginal.ragdoll
                getgenv().antiDamageEnabled = getgenv()._savedOriginal.anti
            end
            getgenv()._savedOriginal = nil
        end
    end)
end







-- ======= ROBUST NEAREST HELPERS (separate, no impact on tween) =======

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

local function getHRP()
    local char = localPlayer and localPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function chooseBestPartFromModel(model)
    if not model then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then
        return model.PrimaryPart
    end
    local commonNames = {"Base","Lid","Cylinder","Place","OpenLootTable","Root","Handle"}
    for _, name in ipairs(commonNames) do
        local part = model:FindFirstChild(name, true)
        if part and part:IsA("BasePart") then
            return part
        end
    end
    return model:FindFirstChildWhichIsA("BasePart", true)
end

-- GET NEAREST AIRDROP (returns the exact Crate part used by ESP)
getgenv().GetNearestAirdrop = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, ad in ipairs(debris:GetChildren()) do
        if ad.Name == "Airdrop" then
            local drop = ad:FindFirstChild("Drop")
            if drop then
                local crate = drop:FindFirstChild("Crate")
                if crate then
                    local part = crate:IsA("BasePart") and crate or crate.PrimaryPart or crate:FindFirstChildWhichIsA("BasePart")
                    if part then
                        local dist = (part.Position - hrp.Position).Magnitude
                        if dist < distMin then
                            nearest, distMin = part, dist
                        end
                    end
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST DRONE LOOT (returns the exact part used by ESP)
getgenv().GetNearestDroneLoot = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local lootFolder = debris:FindFirstChild("Loot")
    if not lootFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, loot in ipairs(lootFolder:GetChildren()) do
        if loot.Name == "DroneLoot" then
            local primary = loot.PrimaryPart or loot:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST TERMINAL (explicitly from workspace.Terminals)
getgenv().GetNearestTerminal = function()
    local terminalsFolder = workspace:FindFirstChild("Terminals")
    if not terminalsFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, terminal in ipairs(terminalsFolder:GetChildren()) do
        if terminal:IsA("Model") then
            local primary = terminal.PrimaryPart or terminal:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        elseif terminal:IsA("BasePart") then
            local dist = (terminal.Position - hrp.Position).Magnitude
            if dist < distMin then
                nearest, distMin = terminal, dist
            end
        end
    end

    return nearest
end

-- TELEPORT 3 STUDS ABOVE TARGET PART OR MODEL
getgenv().TeleportAbove = function(target)
    if not target then return end

    local position
    if target:IsA("BasePart") then
        position = target.Position + Vector3.new(0, 3, 0)
    elseif target:IsA("Model") then
        local primary = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
        if primary then
            position = primary.Position + Vector3.new(0, 3, 0)
        end
    end

    if position then
        getgenv().TweenToPosition(position)
    end
end


local thisTween = tick()
getgenv()._lastTweenFinish = thisTween

task.delay(1, function()
    -- If a newer tween finished, ignore this restore
    if getgenv()._lastTweenFinish ~= thisTween then return end

    getgenv()._tweenActiveCount -= 1

    -- Only restore when NO tweens remain
    if getgenv()._tweenActiveCount == 0 then
        if getgenv()._savedOriginal then
            getgenv().blockRagdoll = getgenv()._savedOriginal.ragdoll
            getgenv().antiDamageEnabled = getgenv()._savedOriginal.anti
        end
        getgenv()._savedOriginal = nil
    end
end)

