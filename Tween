-- =====================================================
--  UNIVERSAL WAYPOINT TWEEN FUNCTION (Safe Tween)  <-- Paste/replace this whole section
--  ✔ FULL 3D MOVEMENT (no more forced horizontal)
-- =====================================================

getgenv()._tweenActiveCount = getgenv()._tweenActiveCount or 0
getgenv()._savedOriginal = getgenv()._savedOriginal or nil
getgenv()._lastTweenFinish = getgenv()._lastTweenFinish or 0

_G.undergroundTweenEnabled = (_G.undergroundTweenEnabled == nil) and true or _G.undergroundTweenEnabled

-- Forbidden Zone (A and B corners)
local ZoneA = Vector3.new(789, 44, -848)
local ZoneB = Vector3.new(411, -10, -1338)

local ZoneMin = Vector3.new(
    math.min(ZoneA.X, ZoneB.X),
    math.min(ZoneA.Y, ZoneB.Y),
    math.min(ZoneA.Z, ZoneB.Z)
)

local ZoneMax = Vector3.new(
    math.max(ZoneA.X, ZoneB.X),
    math.max(ZoneA.Y, ZoneB.Y),
    math.max(ZoneA.Z, ZoneB.Z)
)

local PADDING = 4 -- studs

local function pointInsideZone(v)
    return (
        v.X >= ZoneMin.X and v.X <= ZoneMax.X and
        v.Y >= ZoneMin.Y and v.Y <= ZoneMax.Y and
        v.Z >= ZoneMin.Z and v.Z <= ZoneMax.Z
    )
end

-- robust segment-vs-AABB check used by underground logic (standalone here)
local function segmentIntersectsZone(a, b)
    local dir = b - a
    local tMin, tMax = 0, 1

    local function axisCheck(orig, delta, minB, maxB)
        if math.abs(delta) < 1e-9 then
            if orig < minB or orig > maxB then
                return false, tMin, tMax
            end
            return true, tMin, tMax
        end

        local t1 = (minB - orig) / delta
        local t2 = (maxB - orig) / delta
        if t1 > t2 then t1, t2 = t2, t1 end

        if t2 < tMin or t1 > tMax then
            return false, tMin, tMax
        end

        if t1 > tMin then tMin = t1 end
        if t2 < tMax then tMax = t2 end
        return true, tMin, tMax
    end

    local ok
    ok, tMin, tMax = axisCheck(a.X, dir.X, ZoneMin.X - PADDING, ZoneMax.X + PADDING)
    if not ok then return false end
    ok, tMin, tMax = axisCheck(a.Y, dir.Y, ZoneMin.Y - PADDING, ZoneMax.Y + PADDING)
    if not ok then return false end
    ok, tMin, tMax = axisCheck(a.Z, dir.Z, ZoneMin.Z - PADDING, ZoneMax.Z + PADDING)
    if not ok then return false end

    return true
end

-- Default settings (do not overwrite if already set)
getgenv().antiDamageEnabled = (getgenv().antiDamageEnabled ~= nil) and getgenv().antiDamageEnabled or true
getgenv().blockRagdoll = (getgenv().blockRagdoll ~= nil) and getgenv().blockRagdoll or false

-- =====================================================
--  NORMAL TWEEN (safe)
-- =====================================================
getgenv().NormalTweenToPosition = function(targetPos)
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local player = Players.LocalPlayer
    if not player then return end

    local char = player.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if typeof(targetPos) ~= "Vector3" then return end

    -- BEGIN TWEEN
    if getgenv()._tweenActiveCount == 0 then
        -- first tween → capture real original values
        getgenv()._savedOriginal = {
            ragdoll = getgenv().blockRagdoll,
            anti = getgenv().antiDamageEnabled
        }
    end

    -- if tweens already active → DO NOT overwrite _savedOriginal
    getgenv()._tweenActiveCount += 1

    -- override for tween
    getgenv().blockRagdoll = true
    getgenv().antiDamageEnabled = true
    
    -- perform single straight tween
    local dist = (targetPos - root.Position).Magnitude
    local duration = math.clamp(dist / 150, 0.1, 10)

    local tween = TweenService:Create(
        root,
        TweenInfo.new(duration, Enum.EasingStyle.Linear),
        {CFrame = CFrame.new(targetPos)}
    )
    tween:Play()
    tween.Completed:Wait()

    local thisTween = tick()
    getgenv()._lastTweenFinish = thisTween

    task.delay(0.1, function()
        if getgenv()._lastTweenFinish ~= thisTween then return end

        getgenv()._tweenActiveCount -= 1

        if getgenv()._tweenActiveCount == 0 then
            -- restore ONLY ONCE
            local saved = getgenv()._savedOriginal
            if saved then
                getgenv().blockRagdoll = saved.ragdoll
                getgenv().antiDamageEnabled = saved.anti
            end
            getgenv()._savedOriginal = nil
        end
    end)

end

_G.ForceNormalTween = function(pos)
    if getgenv().NormalTweenToPosition then
        getgenv().NormalTweenToPosition(pos)
    else
        if getgenv().TweenToPosition then
            getgenv().TweenToPosition(pos)
        end
    end
end

-- =====================================================
--  ADVANCED TWEEN WITH UNDERGROUND AVOIDANCE (safe)
-- =====================================================
getgenv().TweenToPosition = function(targetPos)
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local player = Players.LocalPlayer
    if not player then return end

    local char = player.Character
    if not char then return end

    local root = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if typeof(targetPos) ~= "Vector3" then return end

    -- BEGIN TWEEN
    if getgenv()._tweenActiveCount == 0 then
        -- first tween → capture real original values
        getgenv()._savedOriginal = {
            ragdoll = getgenv().blockRagdoll,
            anti = getgenv().antiDamageEnabled
        }
    end

    -- if tweens already active → DO NOT overwrite _savedOriginal
    getgenv()._tweenActiveCount += 1

    -- override for tween
    getgenv().blockRagdoll = true
    getgenv().antiDamageEnabled = true


    -- small helper to tween the HRP to a goal position
    local function doTween(goalPos)
        local dist = (goalPos - root.Position).Magnitude
        local t = math.clamp(dist / 150, 0.1, 10)
        local tween = TweenService:Create(
            root,
            TweenInfo.new(t, Enum.EasingStyle.Linear),
            {CFrame = CFrame.new(goalPos)}
        )
        tween:Play()
        tween.Completed:Wait()
    end

    -------------------------------------------------------------------
    -- MODE A — Normal straight tween
    -------------------------------------------------------------------
    if not _G.undergroundTweenEnabled then
        -- reuse NormalTweenToPosition (it contains its own safe restore)
        getgenv().NormalTweenToPosition(targetPos)
    else
    -------------------------------------------------------------------
    -- MODE B — Underground avoidance pathing
    -------------------------------------------------------------------
        local startPos = root.Position

        local downY = (startPos.Y >= 37) and 25 or (startPos.Y - 12)
        local neededTargetDown = targetPos.Y - 12
        if downY > neededTargetDown then
            downY = neededTargetDown
        end

        local downPos = Vector3.new(startPos.X, downY, startPos.Z)
        doTween(downPos)

        local horizontalY = downY
        local horizStart = downPos
        local horizEnd = Vector3.new(targetPos.X, horizontalY, targetPos.Z)

        local horizontalHitsZone = segmentIntersectsZone(horizStart, horizEnd)

        if horizontalHitsZone and not pointInsideZone(targetPos) then
            local safeY = ZoneMin.Y - 10
            doTween(Vector3.new(startPos.X, safeY, startPos.Z))
            doTween(Vector3.new(targetPos.X, safeY, targetPos.Z))
        else
            doTween(Vector3.new(targetPos.X, horizontalY, targetPos.Z))
        end

        doTween(targetPos)
    end

    -- END: schedule restore for this tween finish
    local thisTween = tick()
    getgenv()._lastTweenFinish = thisTween
    
    task.delay(0.1, function()
        if getgenv()._lastTweenFinish ~= thisTween then return end
    
        getgenv()._tweenActiveCount -= 1
    
        if getgenv()._tweenActiveCount == 0 then
            -- restore ONLY ONCE
            local saved = getgenv()._savedOriginal
            if saved then
                getgenv().blockRagdoll = saved.ragdoll
                getgenv().antiDamageEnabled = saved.anti
            end
            getgenv()._savedOriginal = nil
        end
    end)

end









-- ======= ROBUST NEAREST HELPERS (separate, no impact on tween) =======

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

local function getHRP()
    local char = localPlayer and localPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function chooseBestPartFromModel(model)
    if not model then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then
        return model.PrimaryPart
    end
    local commonNames = {"Base","Lid","Cylinder","Place","OpenLootTable","Root","Handle"}
    for _, name in ipairs(commonNames) do
        local part = model:FindFirstChild(name, true)
        if part and part:IsA("BasePart") then
            return part
        end
    end
    return model:FindFirstChildWhichIsA("BasePart", true)
end

-- GET NEAREST AIRDROP (returns the exact Crate part used by ESP)
getgenv().GetNearestAirdrop = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, ad in ipairs(debris:GetChildren()) do
        if ad.Name == "Airdrop" then
            local drop = ad:FindFirstChild("Drop")
            if drop then
                local crate = drop:FindFirstChild("Crate")
                if crate then
                    local part = crate:IsA("BasePart") and crate or crate.PrimaryPart or crate:FindFirstChildWhichIsA("BasePart")
                    if part then
                        local dist = (part.Position - hrp.Position).Magnitude
                        if dist < distMin then
                            nearest, distMin = part, dist
                        end
                    end
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST DRONE LOOT (returns the exact part used by ESP)
getgenv().GetNearestDroneLoot = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local lootFolder = debris:FindFirstChild("Loot")
    if not lootFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, loot in ipairs(lootFolder:GetChildren()) do
        if loot.Name == "DroneLoot" then
            local primary = loot.PrimaryPart or loot:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST TERMINAL (explicitly from workspace.Terminals)
getgenv().GetNearestTerminal = function()
    local terminalsFolder = workspace:FindFirstChild("Terminals")
    if not terminalsFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, terminal in ipairs(terminalsFolder:GetChildren()) do
        if terminal:IsA("Model") then
            local primary = terminal.PrimaryPart or terminal:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        elseif terminal:IsA("BasePart") then
            local dist = (terminal.Position - hrp.Position).Magnitude
            if dist < distMin then
                nearest, distMin = terminal, dist
            end
        end
    end

    return nearest
end

-- TELEPORT 3 STUDS ABOVE TARGET PART OR MODEL
getgenv().TeleportAbove = function(target)
    if not target then return end

    local position
    if target:IsA("BasePart") then
        position = target.Position + Vector3.new(0, 3, 0)
    elseif target:IsA("Model") then
        local primary = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
        if primary then
            position = primary.Position + Vector3.new(0, 3, 0)
        end
    end

    if position then
        getgenv().TweenToPosition(position)
    end
end


local thisTween = tick()
getgenv()._lastTweenFinish = thisTween

task.delay(1, function()
    -- If a newer tween finished, ignore this restore
    if getgenv()._lastTweenFinish ~= thisTween then return end

    getgenv()._tweenActiveCount -= 1

    -- Only restore when NO tweens remain
    if getgenv()._tweenActiveCount == 0 then
        if getgenv()._savedOriginal then
            getgenv().blockRagdoll = getgenv()._savedOriginal.ragdoll
            getgenv().antiDamageEnabled = getgenv()._savedOriginal.anti
        end
        getgenv()._savedOriginal = nil
    end
end)
