-- =====================================================
--  UNIVERSAL WAYPOINT TWEEN FUNCTION (Safe Tween)
--  ✔ FULL 3D MOVEMENT (no more forced horizontal)
-- =====================================================

_G.undergroundTweenEnabled = _G.undergroundTweenEnabled or false

-- Forbidden Zone (A and B corners)
local ZoneA = Vector3.new(200, 100, 200)
local ZoneB = Vector3.new(100, -100, 130)

local ZoneMin = Vector3.new(
    math.min(ZoneA.X, ZoneB.X),
    math.min(ZoneA.Y, ZoneB.Y),
    math.min(ZoneA.Z, ZoneB.Z)
)

local ZoneMax = Vector3.new(
    math.max(ZoneA.X, ZoneB.X),
    math.max(ZoneA.Y, ZoneB.Y),
    math.max(ZoneA.Z, ZoneB.Z)
)

local PADDING = 3 -- studs

local function pointInsideZone(v)
    return (
        v.X >= ZoneMin.X and v.X <= ZoneMax.X and
        v.Y >= ZoneMin.Y and v.Y <= ZoneMax.Y and
        v.Z >= ZoneMin.Z and v.Z <= ZoneMax.Z
    )
end

-- Default settings
getgenv().antiDamageEnabled = (getgenv().antiDamageEnabled ~= nil) and getgenv().antiDamageEnabled or true
getgenv().blockRagdoll = (getgenv().blockRagdoll ~= nil) and getgenv().blockRagdoll or false

-- =====================================================
--  ADVANCED TWEEN SYSTEM WITH PATHFIND AROUND ZONE
-- =====================================================

getgenv().TweenToPosition = function(targetPos)
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local player = Players.LocalPlayer
    if not player then return end

    local char = player.Character
    if not char then warn("TweenToPosition: character not loaded yet") return end

    local root = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
    if not root then warn("TweenToPosition: no HRP") return end

    if typeof(targetPos) ~= "Vector3" then
        warn("TweenToPosition: invalid Vector3")
        return
    end

    -- Save original protection states
    local originalRagdoll = getgenv().blockRagdoll
    local originalAntiDmg = getgenv().antiDamageEnabled

    getgenv().blockRagdoll = true
    getgenv().antiDamageEnabled = true

    local function doTween(goalPos)
        local dist = (goalPos - root.Position).Magnitude
        local t = math.clamp(dist * (1/150), 0.1, 10)

        local tween = TweenService:Create(
            root,
            TweenInfo.new(t, Enum.EasingStyle.Linear),
            {CFrame = CFrame.new(goalPos)}
        )
        tween:Play()
        tween.Completed:Wait()
    end

    ---------------------------------------------------------
    -- MODE A — NORMAL DIRECT TWEEN (no underground)
    ---------------------------------------------------------
    if not _G.undergroundTweenEnabled then
        doTween(targetPos)
    else
    ---------------------------------------------------------
    -- MODE B — ADVANCED UNDERGROUND WITH ZONE AVOIDANCE
    ---------------------------------------------------------
        local startPos = root.Position

        -----------------------------------------------------
        -- RULE: DETERMINE FIRST DESCENT HEIGHT
        -----------------------------------------------------
        local downY
        if startPos.Y >= 37 then
            downY = 27
        else
            downY = startPos.Y - 10
        end

        -- Also ensure we are 10 under target at horizontal
        local neededTargetDown = targetPos.Y - 10
        if downY > neededTargetDown then
            downY = neededTargetDown
        end

        -- Main three points
        local downPos     = Vector3.new(startPos.X, downY, startPos.Z)
        local horizontalY = downY
        local upPos       = targetPos

        -----------------------------------------------------
        -- ZONE CHECK — Determine if direct horizontal path intersects zone
        -----------------------------------------------------
        local function segmentIntersectsZone(a, b)
            -- Check only XZ (horizontal cross-section)
            local function clamp(v, min, max)
                return math.max(min, math.min(max, v))
            end

            -- closest point from segment AB to AABB
            local function closestPointOnSegment(p, q, pnt)
                local t = ((pnt - p):Dot(q - p)) / ((q - p).Magnitude^2)
                t = clamp(t, 0, 1)
                return p + (q - p) * t
            end

            local segA = Vector3.new(a.X, 0, a.Z)
            local segB = Vector3.new(b.X, 0, b.Z)

            local zoneCenter = Vector3.new(
                (ZoneMin.X + ZoneMax.X)/2,
                0,
                (ZoneMin.Z + ZoneMax.Z)/2
            )

            local cp = closestPointOnSegment(segA, segB, zoneCenter)

            return (
                cp.X >= ZoneMin.X - PADDING and cp.X <= ZoneMax.X + PADDING and
                cp.Z >= ZoneMin.Z - PADDING and cp.Z <= ZoneMax.Z + PADDING
            )
        end

        -- HORIZONTAL POINTS for PATH OPTIONS
        local leftX  = ZoneMin.X - PADDING  
        local rightX = ZoneMax.X + PADDING 
        local underY = ZoneMin.Y - PADDING 

        local leftPathPos1  = Vector3.new(leftX,  horizontalY, startPos.Z)
        local leftPathPos2  = Vector3.new(leftX,  horizontalY, targetPos.Z)

        local rightPathPos1 = Vector3.new(rightX, horizontalY, startPos.Z)
        local rightPathPos2 = Vector3.new(rightX, horizontalY, targetPos.Z)

        local underPathY = underY
        local underPos1  = Vector3.new(startPos.X, underPathY, startPos.Z)
        local underPos2  = Vector3.new(targetPos.X, underPathY, targetPos.Z)

        -----------------------------------------------------
        -- Determine costs (choose shortest path)
        -----------------------------------------------------
        local function dist(a, b) return (a - b).Magnitude end

        local costLeft =
            dist(downPos, leftPathPos1) +
            dist(leftPathPos1, leftPathPos2) +
            dist(leftPathPos2, Vector3.new(targetPos.X, horizontalY, targetPos.Z))

        local costRight =
            dist(downPos, rightPathPos1) +
            dist(rightPathPos1, rightPathPos2) +
            dist(rightPathPos2, Vector3.new(targetPos.X, horizontalY, targetPos.Z))

        local costUnder =
            dist(downPos, underPos1) +
            dist(underPos1, underPos2) +
            dist(underPos2, Vector3.new(targetPos.X, horizontalY, targetPos.Z))

        -----------------------------------------------------
        -- Choose best path
        -----------------------------------------------------
        local best = "under"
        local bestCost = costUnder

        if costLeft < bestCost then best, bestCost = "left", costLeft end
        if costRight < bestCost then best, bestCost = "right", costRight end

        -----------------------------------------------------
        -- EXECUTE PATH
        -----------------------------------------------------

        -- DOWN
        doTween(downPos)

        if best == "left" then
            doTween(leftPathPos1)
            doTween(leftPathPos2)
            doTween(Vector3.new(targetPos.X, horizontalY, targetPos.Z))

        elseif best == "right" then
            doTween(rightPathPos1)
            doTween(rightPathPos2)
            doTween(Vector3.new(targetPos.X, horizontalY, targetPos.Z))

        else -- "under"
            doTween(underPos1)
            doTween(underPos2)
            doTween(Vector3.new(targetPos.X, horizontalY, targetPos.Z))
        end

        -- UP
        doTween(upPos)
    end

    -- Restore protection 1 sec later
    task.delay(1, function()
        getgenv().blockRagdoll = originalRagdoll
        getgenv().antiDamageEnabled = originalAntiDmg
    end)
end






-- ======= ROBUST NEAREST HELPERS (separate, no impact on tween) =======

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

local function getHRP()
    local char = localPlayer and localPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function chooseBestPartFromModel(model)
    if not model then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then
        return model.PrimaryPart
    end
    local commonNames = {"Base","Lid","Cylinder","Place","OpenLootTable","Root","Handle"}
    for _, name in ipairs(commonNames) do
        local part = model:FindFirstChild(name, true)
        if part and part:IsA("BasePart") then
            return part
        end
    end
    return model:FindFirstChildWhichIsA("BasePart", true)
end

-- GET NEAREST AIRDROP (returns the exact Crate part used by ESP)
getgenv().GetNearestAirdrop = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, ad in ipairs(debris:GetChildren()) do
        if ad.Name == "Airdrop" then
            local drop = ad:FindFirstChild("Drop")
            if drop then
                local crate = drop:FindFirstChild("Crate")
                if crate then
                    local part = crate:IsA("BasePart") and crate or crate.PrimaryPart or crate:FindFirstChildWhichIsA("BasePart")
                    if part then
                        local dist = (part.Position - hrp.Position).Magnitude
                        if dist < distMin then
                            nearest, distMin = part, dist
                        end
                    end
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST DRONE LOOT (returns the exact part used by ESP)
getgenv().GetNearestDroneLoot = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local lootFolder = debris:FindFirstChild("Loot")
    if not lootFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, loot in ipairs(lootFolder:GetChildren()) do
        if loot.Name == "DroneLoot" then
            local primary = loot.PrimaryPart or loot:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST TERMINAL (explicitly from workspace.Terminals)
getgenv().GetNearestTerminal = function()
    local terminalsFolder = workspace:FindFirstChild("Terminals")
    if not terminalsFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, terminal in ipairs(terminalsFolder:GetChildren()) do
        if terminal:IsA("Model") then
            local primary = terminal.PrimaryPart or terminal:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        elseif terminal:IsA("BasePart") then
            local dist = (terminal.Position - hrp.Position).Magnitude
            if dist < distMin then
                nearest, distMin = terminal, dist
            end
        end
    end

    return nearest
end

-- TELEPORT 3 STUDS ABOVE TARGET PART OR MODEL
getgenv().TeleportAbove = function(target)
    if not target then return end

    local position
    if target:IsA("BasePart") then
        position = target.Position + Vector3.new(0, 3, 0)
    elseif target:IsA("Model") then
        local primary = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
        if primary then
            position = primary.Position + Vector3.new(0, 3, 0)
        end
    end

    if position then
        getgenv().TweenToPosition(position)
    end
end
