-- =====================================================
--  UNIVERSAL WAYPOINT TWEEN FUNCTION (Safe Tween)
--  ✔ FULL 3D MOVEMENT (no more forced horizontal)
-- =====================================================

_G.undergroundTweenEnabled = _G.undergroundTweenEnabled or false

-- Forbidden Zone (A and B corners)
local ZoneA = Vector3.new(789, 44, -848)
local ZoneB = Vector3.new(411, -10, -1338)

local ZoneMin = Vector3.new(
    math.min(ZoneA.X, ZoneB.X),
    math.min(ZoneA.Y, ZoneB.Y),
    math.min(ZoneA.Z, ZoneB.Z)
)

local ZoneMax = Vector3.new(
    math.max(ZoneA.X, ZoneB.X),
    math.max(ZoneA.Y, ZoneB.Y),
    math.max(ZoneA.Z, ZoneB.Z)
)

local PADDING = 3 -- studs

local function pointInsideZone(v)
    return (
        v.X >= ZoneMin.X and v.X <= ZoneMax.X and
        v.Y >= ZoneMin.Y and v.Y <= ZoneMax.Y and
        v.Z >= ZoneMin.Z and v.Z <= ZoneMax.Z
    )
end

-- Default settings
getgenv().antiDamageEnabled = (getgenv().antiDamageEnabled ~= nil) and getgenv().antiDamageEnabled or true
getgenv().blockRagdoll = (getgenv().blockRagdoll ~= nil) and getgenv().blockRagdoll or false

-- =====================================================
--  ADVANCED TWEEN SYSTEM WITH PATHFIND AROUND ZONE
-- =====================================================

getgenv().TweenToPosition = function(targetPos)
    local Players = game:GetService("Players")
    local TweenService = game:GetService("TweenService")
    local player = Players.LocalPlayer
    if not player then return end

    local char = player.Character
    if not char then warn("TweenToPosition: character not loaded yet") return end

    local root = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
    if not root then warn("TweenToPosition: no HRP") return end

    if typeof(targetPos) ~= "Vector3" then
        warn("TweenToPosition: invalid Vector3")
        return
    end

    -- Save original protection states
    local originalRagdoll = getgenv().blockRagdoll
    local originalAntiDmg = getgenv().antiDamageEnabled

    getgenv().blockRagdoll = true
    getgenv().antiDamageEnabled = true

    local function doTween(goalPos)
        local dist = (goalPos - root.Position).Magnitude
        local t = math.clamp(dist * (1/150), 0.1, 10)

        local tween = TweenService:Create(
            root,
            TweenInfo.new(t, Enum.EasingStyle.Linear),
            {CFrame = CFrame.new(goalPos)}
        )
        tween:Play()
        tween.Completed:Wait()
    end

    ---------------------------------------------------------
    -- MODE A — NORMAL DIRECT TWEEN (no underground)
    ---------------------------------------------------------
    if not _G.undergroundTweenEnabled then
        doTween(targetPos)
    else
    ---------------------------------------------------------
    -- MODE B — ADVANCED UNDERGROUND WITH ZONE AVOIDANCE
    ---------------------------------------------------------
        local startPos = root.Position

        -----------------------------------------------------
        -- RULE: DETERMINE FIRST DESCENT HEIGHT
        -----------------------------------------------------
        local downY
        if startPos.Y >= 37 then
            downY = 27
        else
            downY = startPos.Y - 10
        end

        -- Also ensure we are 10 under target at horizontal
        local neededTargetDown = targetPos.Y - 10
        if downY > neededTargetDown then
            downY = neededTargetDown
        end

        -- Main three points
        local downPos     = Vector3.new(startPos.X, downY, startPos.Z)
        local horizontalY = downY
        local upPos       = targetPos

        -----------------------------------------------------
        -- ZONE CHECK — Determine if direct horizontal path intersects zone
        -----------------------------------------------------
        local function segmentIntersectsZone(a, b)
            -- Line segment vs AABB intersection test (3D)
            local dir = b - a
            local tMin = 0
            local tMax = 1

            local function axisCheck(axis, minB, maxB)
                local origin = a[axis]
                local direction = dir[axis]

                if math.abs(direction) < 1e-6 then
                    return origin >= minB and origin <= maxB
                end

                local t1 = (minB - origin) / direction
                local t2 = (maxB - origin) / direction
                if t1 > t2 then t1, t2 = t2, t1 end

                if t2 < tMin or t1 > tMax then
                    return false
                end

                if t1 > tMin then tMin = t1 end
                if t2 < tMax then tMax = t2 end
                return true
            end

            return
                axisCheck("X", ZoneMin.X - PADDING, ZoneMax.X + PADDING) and
                axisCheck("Y", ZoneMin.Y - PADDING, ZoneMax.Y + PADDING) and
                axisCheck("Z", ZoneMin.Z - PADDING, ZoneMax.Z + PADDING)
        end


        -- HORIZONTAL POINTS for PATH OPTIONS
        local leftX  = ZoneMin.X - PADDING  
        local rightX = ZoneMax.X + PADDING 
        local underY = ZoneMin.Y - PADDING 

        local leftPathPos1  = Vector3.new(leftX,  horizontalY, startPos.Z)
        local leftPathPos2  = Vector3.new(leftX,  horizontalY, targetPos.Z)

        local rightPathPos1 = Vector3.new(rightX, horizontalY, startPos.Z)
        local rightPathPos2 = Vector3.new(rightX, horizontalY, targetPos.Z)

        local underPathY = underY
        local underPos1  = Vector3.new(startPos.X, underPathY, startPos.Z)
        local underPos2  = Vector3.new(targetPos.X, underPathY, targetPos.Z)

        -----------------------------------------------------
        -- If horizontal path intersects zone → ALWAYS go under
        -----------------------------------------------------
        local horizStart = downPos
        local horizEnd   = Vector3.new(targetPos.X, horizontalY, targetPos.Z)

        local horizontalHitsZone =
            segmentIntersectsZone(horizStart, horizEnd)

        local best = "straight"

        if horizontalHitsZone and not pointInsideZone(targetPos) then
            best = "underZone"  -- override everything
        end


        -----------------------------------------------------
        -- EXECUTE PATH
        -----------------------------------------------------

        -- DOWN
        doTween(downPos)

        if best == "underZone" then
            -- Force path to bottom of zone - 10
            local safeY = ZoneMin.Y - 10

            local under1 = Vector3.new(startPos.X, safeY, startPos.Z)
            local under2 = Vector3.new(targetPos.X, safeY, targetPos.Z)

            doTween(under1)
            doTween(under2)

        else
            -- Normal horizontal
            doTween(Vector3.new(targetPos.X, horizontalY, targetPos.Z))
        end

        -- UP
        doTween(upPos)
    end

    -- Restore protection 1 sec later
    task.delay(1, function()
        getgenv().blockRagdoll = originalRagdoll
        getgenv().antiDamageEnabled = originalAntiDmg
    end)
end






-- ======= ROBUST NEAREST HELPERS (separate, no impact on tween) =======

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local localPlayer = Players.LocalPlayer

local function getHRP()
    local char = localPlayer and localPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function chooseBestPartFromModel(model)
    if not model then return nil end
    if model.PrimaryPart and model.PrimaryPart:IsA("BasePart") then
        return model.PrimaryPart
    end
    local commonNames = {"Base","Lid","Cylinder","Place","OpenLootTable","Root","Handle"}
    for _, name in ipairs(commonNames) do
        local part = model:FindFirstChild(name, true)
        if part and part:IsA("BasePart") then
            return part
        end
    end
    return model:FindFirstChildWhichIsA("BasePart", true)
end

-- GET NEAREST AIRDROP (returns the exact Crate part used by ESP)
getgenv().GetNearestAirdrop = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, ad in ipairs(debris:GetChildren()) do
        if ad.Name == "Airdrop" then
            local drop = ad:FindFirstChild("Drop")
            if drop then
                local crate = drop:FindFirstChild("Crate")
                if crate then
                    local part = crate:IsA("BasePart") and crate or crate.PrimaryPart or crate:FindFirstChildWhichIsA("BasePart")
                    if part then
                        local dist = (part.Position - hrp.Position).Magnitude
                        if dist < distMin then
                            nearest, distMin = part, dist
                        end
                    end
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST DRONE LOOT (returns the exact part used by ESP)
getgenv().GetNearestDroneLoot = function()
    local debris = workspace:FindFirstChild("Debris")
    if not debris then return nil end
    local lootFolder = debris:FindFirstChild("Loot")
    if not lootFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, loot in ipairs(lootFolder:GetChildren()) do
        if loot.Name == "DroneLoot" then
            local primary = loot.PrimaryPart or loot:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        end
    end

    return nearest
end

-- GET NEAREST TERMINAL (explicitly from workspace.Terminals)
getgenv().GetNearestTerminal = function()
    local terminalsFolder = workspace:FindFirstChild("Terminals")
    if not terminalsFolder then return nil end
    local hrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local nearest, distMin = nil, math.huge

    for _, terminal in ipairs(terminalsFolder:GetChildren()) do
        if terminal:IsA("Model") then
            local primary = terminal.PrimaryPart or terminal:FindFirstChildWhichIsA("BasePart")
            if primary then
                local dist = (primary.Position - hrp.Position).Magnitude
                if dist < distMin then
                    nearest, distMin = primary, dist
                end
            end
        elseif terminal:IsA("BasePart") then
            local dist = (terminal.Position - hrp.Position).Magnitude
            if dist < distMin then
                nearest, distMin = terminal, dist
            end
        end
    end

    return nearest
end

-- TELEPORT 3 STUDS ABOVE TARGET PART OR MODEL
getgenv().TeleportAbove = function(target)
    if not target then return end

    local position
    if target:IsA("BasePart") then
        position = target.Position + Vector3.new(0, 3, 0)
    elseif target:IsA("Model") then
        local primary = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
        if primary then
            position = primary.Position + Vector3.new(0, 3, 0)
        end
    end

    if position then
        getgenv().TweenToPosition(position)
    end
end
